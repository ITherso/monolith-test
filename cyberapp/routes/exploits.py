# cyberapp/routes/exploits.py

from flask import Blueprint, render_template, request, jsonify
from flask_socketio import emit
from cybermodules.autoexploit import AutoExploitEngine
from cyberapp.extensions import socketio


class _NoopSocketIO:
    def on(self, *_args, **_kwargs):
        def _decorator(func):
            return func

        return _decorator


socketio = socketio or _NoopSocketIO()

exploits_bp = Blueprint('exploits', __name__, template_folder='templates')

_engine = None


def _get_engine():
    global _engine
    if _engine is not None:
        return _engine
    try:
        _engine = AutoExploitEngine()
    except Exception:
        _engine = None
    return _engine

@exploits_bp.route('/exploits')
def exploits_dashboard():
    return render_template('exploits.html')

@exploits_bp.route('/api/exploit', methods=['POST'])
def api_exploit():
    data = request.json
    engine = _get_engine()
    if engine is None:
        return jsonify({"error": "autoexploit_unavailable"}), 503
    exploits = engine.search_exploit(data.get('query', ''))
    return jsonify({"exploits": exploits[:10]})  # ilk 10

@exploits_bp.route('/api/chain', methods=['POST'])
def chain_exploit():
    data = request.json
    engine = _get_engine()
    if engine is None:
        return jsonify({"error": "autoexploit_unavailable"}), 503
    result = engine.exploit_vuln(
        target_ip=data['ip'],
        target_port=data.get('port'),
        exploit_module=data['module'],
        lhost=data['lhost'],
        lport=data.get('lport', 4444)
    )
    return jsonify(result)

@exploits_bp.route('/api/sessions')
def sessions():
    engine = _get_engine()
    if engine is None:
        return jsonify({"error": "autoexploit_unavailable"}), 503
    return jsonify(engine.get_sessions())

@socketio.on('shell_command')
def handle_shell(data):
    session_id = data['session_id']
    command = data['command']
    engine = _get_engine()
    if engine is None:
        emit('shell_output', {'output': 'autoexploit_unavailable', 'session_id': session_id})
        return
    output = engine.shell_interact(session_id, command)
    emit('shell_output', {'output': output, 'session_id': session_id})
